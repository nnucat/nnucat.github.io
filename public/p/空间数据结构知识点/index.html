<!DOCTYPE html>
<html lang="zh-cn">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content='空间数据结构期末复习知识点'><title>空间数据结构知识点</title>

<link rel='canonical' href='https://nnuni.com/p/%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9/'>

<link rel="stylesheet" href="/scss/style.min.bbcfef3c56489f1f37b552146da519e6b6a74a4c92792bcc512c78e2f55f25e1.css"><meta property='og:title' content='空间数据结构知识点'>
<meta property='og:description' content='空间数据结构期末复习知识点'>
<meta property='og:url' content='https://nnuni.com/p/%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9/'>
<meta property='og:site_name' content='只是一个仓库'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:tag' content='数据结构' /><meta property='article:published_time' content='2022-01-02T10:00:00&#43;08:00'/><meta property='article:modified_time' content='2022-01-02T10:00:00&#43;08:00'/>
<meta name="twitter:title" content="空间数据结构知识点">
<meta name="twitter:description" content="空间数据结构期末复习知识点">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-Y0RPPV7WDV"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-Y0RPPV7WDV', { 'anonymize_ip': false });
}
</script>

    </head>
    <body class="
    article-page has-toc
">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex 
    
        extended
    
">
    
        <div id="article-toolbar">
            <a href="/" class="back-home">
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="15 6 9 12 15 18" />
</svg>



                <span>返回</span>
            </a>
        </div>
    
<main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    

    <h2 class="article-title">
        <a href="/p/%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9/">空间数据结构知识点</a>
    </h2>

    

    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">2022-01-02</time>
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    阅读时长: 35 分钟
                </time>
            </div>
        
    </footer>
    
</div>
</header>

    <section class="article-content">
    
    
    <h1 id="数据结构">数据结构</h1>
<h2 id="数据结构入门">数据结构入门</h2>
<h3 id="数据结构基础知识">数据结构基础知识</h3>
<ol>
<li>
<p><strong>数据</strong>是对客观事物的符号表示。</p>
</li>
<li>
<p><strong>数据元素</strong>是数据的基本单位，也称节点或记录。</p>
</li>
<li>
<p><strong>数据项</strong>是数据的不分割的最小单位。</p>
</li>
<li>
<p><strong>数据对象</strong>是性质相同的数据元素的集合，是数据的一个子集。</p>
</li>
<li>
<p><strong>数据结构</strong>是相互之间存在一种或多种特定关系的数据元素的集合。</p>
</li>
<li>
<p>数据元素相互之间的关系称为<strong>结构</strong>。</p>
</li>
<li>
<p><strong>逻辑结构</strong>是数据元素间抽象化的逻辑关系，它是从具体问题中抽象出来的数学模型。</p>
</li>
<li>
<p>四类基本<strong>逻辑结构</strong>：</p>
<ul>
<li><strong>集合</strong></li>
<li><strong>线性结构</strong></li>
<li><strong>树形结构</strong></li>
<li><strong>图状结构</strong>或<strong>网状结构</strong></li>
</ul>
</li>
<li>
<p>数据结构在计算机中的表示称为数据的<strong>存储结构</strong>。</p>
</li>
<li>
<p>两种不同的存储结构：<strong>顺式存储结构</strong>和<strong>链式存储结构</strong>。</p>
</li>
<li>
<p><strong>数据类型</strong>是一个<!-- raw HTML omitted --><strong>值的集合</strong><!-- raw HTML omitted -->和定义在这个值集上的<!-- raw HTML omitted --><strong>一组操作</strong><!-- raw HTML omitted -->的总称。</p>
</li>
<li>
<p>高级程序语言中的数据类型可分为两类：</p>
<ul>
<li>非结构的<strong>原子类型</strong></li>
<li><strong>结构类型</strong></li>
</ul>
</li>
<li>
<p>**抽象数据类型（ADT）**是指一个数学模型以及定义在该模型上的一组操作。</p>
</li>
<li>
<p>一个含抽象数据类型的软件模块通常应该包括定义、表现和实现三部分。</p>
</li>
<li>
<p>抽象数据类型按其值的不同特性，可细分为下列三种类型：</p>
<ul>
<li><strong>原子类型</strong>属原子类型的变量的值是不可分解的。</li>
<li><strong>固定聚合类型</strong>是该类型的变量，其值由确定数目的成分按某种结构组成。</li>
<li><strong>可变聚合类型</strong>和固定聚合类型相比较，构成可变聚合类型“值”的成分的数目不确定。</li>
</ul>
</li>
<li>
<p>抽象数据类型可用**（D,S,P）**三元组表示，其中，D是数据对象，S是D上的关系集，P是对D的基本操作集。</p>
</li>
<li>
<p>抽象数据类型定义：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">ADT</span> <span class="err">抽象数据类型名</span><span class="p">{</span>
<span class="err">数据对象：</span><span class="o">&lt;</span><span class="err">数据对象的定义</span><span class="o">&gt;</span>
<span class="err">数据关系：</span><span class="o">&lt;</span><span class="err">数据关系的定义</span><span class="o">&gt;</span>
<span class="err">基本操作：</span><span class="o">&lt;</span><span class="err">基本操作的定义</span><span class="o">&gt;</span>
<span class="p">}</span> <span class="n">ADT</span> <span class="err">抽象数据类型名</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>算法是对特定问题求解步骤的一种描述，此外，一个算法还具有下列5个重要特性：</p>
<ul>
<li><strong>有穷性</strong></li>
<li><strong>确定性</strong></li>
<li><strong>可行性</strong></li>
<li><strong>输入</strong></li>
<li><strong>输出</strong></li>
</ul>
</li>
<li>
<p>算法设计的要求：</p>
<ul>
<li><strong>正确性</strong></li>
<li><strong>可读性</strong></li>
<li><strong>健壮性</strong></li>
<li><strong>效率与低存储量要求</strong></li>
</ul>
</li>
</ol>
<h3 id="算法效率的度量">算法效率的度量</h3>
<ol>
<li>时间复杂度</li>
<li>空间复杂度</li>
</ol>
<h2 id="线性表">线性表</h2>
<h3 id="顺序表">顺序表</h3>
<h4 id="顺序表的静态分配">顺序表的静态分配</h4>
<p>静态分配采用定长数组进行分配，但可能会出现溢出问题。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#define MAXSIZE 100
</span><span class="cp"></span><span class="k">typedef</span> <span class="k">struct</span><span class="p">{</span>
    <span class="kt">int</span> <span class="n">data</span><span class="p">[</span><span class="n">MAXSIZE</span><span class="p">];</span>	<span class="c1">//以整型为例，实际采用ElemType，使用时只需在文件头typedef int ElemType;
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">length</span><span class="p">;</span>			<span class="c1">//length记录元素个数
</span><span class="c1"></span><span class="p">}</span><span class="n">SqList</span><span class="p">;</span>				<span class="c1">//使用typedef简化类型声明，如定义一个顺序表只需SqList L；
</span></code></pre></td></tr></table>
</div>
</div><h4 id="顺序表的动态分配">顺序表的动态分配</h4>
<p>动态分配采用指针，以<code>elem</code>作为空间的基地址（首地址），<code>length</code>记录元素个数（顺序表长度）。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#define MAXSIZE 100
</span><span class="cp">#define LISTINCREMENT 10 
</span><span class="cp"></span><span class="c1">//存储空间分配增量
</span><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span><span class="p">{</span>
    <span class="n">ElemType</span> <span class="o">*</span><span class="n">elem</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">length</span><span class="p">;</span>			<span class="c1">//length记录元素个数
</span><span class="c1"></span>	<span class="kt">int</span> <span class="n">listsize</span><span class="p">;</span>       <span class="c1">//当前分配的存储容量（以sizeof(Elemtype)为单位）
</span><span class="c1"></span><span class="p">}</span><span class="n">SqList</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="顺序表的基本操作">顺序表的基本操作</h4>
<p>以动态分配为例，分别用C语言写出顺序表的初始化、创建、取值、查找、插入、删除等基本操作。</p>
<h5 id="获得元素">获得元素</h5>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#define OK 1
</span><span class="cp">#define ERROR 0
</span><span class="cp">#define TRUE 1
</span><span class="cp">#define FALSE 1
</span><span class="cp"></span><span class="k">typedef</span> <span class="kt">int</span> <span class="n">Status</span><span class="p">;</span>
<span class="cm">/* Status是函数的类型，其值是函数结果状态代码 */</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* 初始条件：顺序线性表L已存在，1 ≤ i ≤ ListLength(L) */</span>
<span class="cm">/* 操作结果：用e返回L中第i个数据元素的值 */</span>
<span class="n">Status</span> <span class="nf">GetElem</span><span class="p">(</span><span class="n">SqList</span> <span class="n">L</span><span class="p">,</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">ElemType</span> <span class="o">*</span><span class="n">e</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">L</span><span class="p">.</span><span class="n">length</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">1</span> <span class="o">||</span> <span class="n">i</span><span class="o">&gt;</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ERROR</span><span class="p">;</span>
    <span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="n">L</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
    <span class="k">return</span> <span class="n">OK</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h5 id="初始化">初始化</h5>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">Status</span> <span class="nf">InitList</span><span class="p">(</span><span class="n">SQList</span> <span class="o">&amp;</span><span class="n">L</span><span class="p">){</span>
	<span class="c1">//构造一个空的线性表L
</span><span class="c1"></span>	<span class="n">L</span><span class="p">.</span><span class="n">elem</span> <span class="o">=</span> <span class="p">(</span><span class="n">ElemType</span> <span class="o">*</span> <span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">MAXSIZE</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ElemType</span><span class="p">));</span>
	<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">L</span><span class="p">.</span><span class="n">elem</span><span class="p">)</span> <span class="n">exit</span><span class="p">(</span><span class="n">OVERFLOW</span><span class="p">);</span>    <span class="c1">//存储空间分配失败
</span><span class="c1"></span>	<span class="n">L</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>    <span class="err">空表长度为</span><span class="mi">0</span>
	<span class="n">L</span><span class="p">.</span><span class="n">listsize</span> <span class="o">=</span> <span class="n">MAXSIZE</span><span class="p">;</span>    <span class="c1">//初始存储容量
</span><span class="c1"></span>	<span class="k">return</span> <span class="n">OK</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h5 id="查找">查找</h5>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">LocateElem</span><span class="p">(</span><span class="n">SqList</span> <span class="n">L</span><span class="p">,</span> <span class="n">ElemType</span> <span class="n">e</span><span class="p">,</span>
              <span class="n">Status</span><span class="p">(</span><span class="o">*</span> <span class="n">compare</span><span class="p">)(</span><span class="n">ElemType</span><span class="p">,</span> <span class="n">Elemtype</span><span class="p">)){</span>
    <span class="c1">//在顺序线性表L中查找第一个值与e满足compare()的位序
</span><span class="c1"></span>    <span class="c1">// 若找到，则返回其在L中的位序，否则返回0
</span><span class="c1"></span>    <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>		<span class="c1">//i的初值为第一个元素的位序
</span><span class="c1"></span>    <span class="n">p</span> <span class="o">=</span> <span class="n">L</span><span class="p">.</span><span class="n">elem</span><span class="p">;</span>	<span class="c1">//p的初值为第一个元素的存储位置
</span><span class="c1"></span>    <span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">L</span><span class="p">.</span><span class="n">length</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="n">compare</span><span class="p">)(</span><span class="o">*</span><span class="n">p</span><span class="o">++</span><span class="p">,</span><span class="n">e</span><span class="p">))</span> 
        <span class="o">++</span><span class="n">i</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h5 id="插入">插入</h5>
<p>插入算法的思路：</p>
<ul>
<li>如果插入位置不合理，抛出异常；</li>
<li>如果线性表长度大于数组长度，抛出异常或动态增加容量；</li>
<li>从最后一个元素开始向前遍历到第i个位置，分别将它们都向后移动一个位置；</li>
<li>将要插入元素填入i处；</li>
<li>表长加1。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* 初始条件：顺序线性表L已存在，1 ≤ i ≤ ListLength(L) */</span>
<span class="cm">/* 操作结果：在L中第i个位置之前插入新的数据元素e，L的长度加1 */</span>
<span class="n">Status</span> <span class="nf">ListInsert</span><span class="p">(</span><span class="n">SqList</span> <span class="o">*</span><span class="n">L</span><span class="p">,</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">ElemType</span> <span class="n">e</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">k</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">==</span> <span class="n">MAXSIZE</span><span class="p">)</span> <span class="cm">/*顺序线性表已满*/</span>
        <span class="k">return</span> <span class="n">ERROR</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">1</span> <span class="o">||</span> <span class="n">i</span><span class="o">&gt;</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">length</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="cm">/*当i不在范围内时*/</span>
        <span class="k">return</span> <span class="n">ERROR</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">L</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span>	<span class="cm">/*若插入数据位置不在表尾*/</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">length</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="n">k</span><span class="o">&gt;=</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="n">k</span><span class="o">--</span><span class="p">)</span>
            <span class="cm">/*将要插入位置后数据元素向后移动一位*/</span>
            <span class="n">L</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">L</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="n">L</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span> <span class="cm">/*将新元素插入*/</span>
    <span class="n">L</span><span class="o">-&gt;</span><span class="n">length</span><span class="o">++</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">OK</span><span class="p">;</span>    
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h5 id="删除">删除</h5>
<p>删除算法的思路：</p>
<ul>
<li>如果删除位置不合理，抛出异常；</li>
<li>取出删除元素；</li>
<li>从删除元素位置开始遍历到最后一个元素位置，分别将它们都向前移动一个位置；</li>
<li>表长减1。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* 初始条件：顺序线性表L已存在，1 ≤ i ≤ ListLength(L) */</span>
<span class="cm">/* 操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减1 */</span>
<span class="n">Status</span> <span class="nf">ListDelete</span><span class="p">(</span><span class="n">SqList</span> <span class="o">*</span><span class="n">L</span><span class="p">,</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">ElemType</span> <span class="o">*</span><span class="n">e</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">k</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>		<span class="cm">/*线性表为空*/</span>
        <span class="k">return</span> <span class="n">ERROR</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">1</span> <span class="o">||</span> <span class="n">i</span><span class="o">&gt;</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span>	<span class="cm">/*删除位置不正确*/</span>
        <span class="k">return</span> <span class="n">ERROR</span><span class="p">;</span>
    <span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="n">L</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">L</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="n">i</span><span class="p">;</span><span class="n">k</span> <span class="o">&lt;</span> <span class="n">L</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span><span class="n">k</span><span class="o">++</span><span class="p">)</span>
            <span class="n">L</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">L</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="n">L</span><span class="o">-&gt;</span><span class="n">length</span><span class="o">--</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">OK</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="线性表顺序存储结构的优缺点">线性表顺序存储结构的优缺点</h4>
<div class="table-wrapper"><table>
<thead>
<tr>
<th style="text-align:left">优点</th>
<th style="text-align:left">缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">无需为表示表中元素之间的逻辑关系而增加额外的存储空间</td>
<td style="text-align:left">插入和删除操作需要移动大量元素</td>
</tr>
<tr>
<td style="text-align:left">可以快速的存取表中任一位置的元素</td>
<td style="text-align:left">当线性表长度变化较大时，难以确定存储空间的容量</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">造成存储空间的碎片化</td>
</tr>
</tbody>
</table></div>
<h3 id="线性表的链式存储结构">线性表的链式存储结构</h3>
<h4 id="头指针与头结点的异同">头指针与头结点的异同</h4>
<div class="table-wrapper"><table>
<thead>
<tr>
<th>头指针</th>
<th>头结点</th>
</tr>
</thead>
<tbody>
<tr>
<td>头指针是指链表指向第一个结点的指针，若链表有头结点，则是指向头结点的指针</td>
<td>头结点是为了操作的统一和方便而设立的，放在第一元素的结点之前，其数据域一般无意义（也可存放链表的长度）</td>
</tr>
<tr>
<td>头指针具有标识作用，所以常常用头指针冠以链表的名字</td>
<td>有了头结点，对在第一元素结点前插入结点和删除第一结点，其操作与其他结点操作相同</td>
</tr>
<tr>
<td>无论链表是否为空，头指针均不为空。头指针是链表的必要元素</td>
<td>头结点不一定是链表必须要素</td>
</tr>
</tbody>
</table></div>
<h4 id="线性表的单链表存储结构">线性表的单链表存储结构</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">Node</span><span class="p">{</span>
    <span class="n">ElemType</span> <span class="n">data</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">Node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>    
<span class="p">}</span><span class="n">Node</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">Node</span> <span class="o">*</span><span class="n">LinkList</span><span class="p">;</span>	<span class="cm">/*定义LinkList;*/</span>
</code></pre></td></tr></table>
</div>
</div><p>假设p是指向线性表第i个元素的指针，则该结点a~i~的数据域可以用<code>p-&gt;data</code>表示，<code>p-&gt;data</code>的值是一个数据元素，结点a~i~的指针域可以用<code>p-&gt;next</code>来表示，<code>p-&gt;next</code>的值是一个指针。<code>p-&gt;next</code>是指向a~i+1~的指针。也就是说，如果<code>p-&gt;data</code>=a~i~，那么<code>p-&gt;next-&gt;data</code>=a~i+1~。</p>
<h4 id="单链表的读取">单链表的读取</h4>
<p>获得链表第i个数据的算法思路：</p>
<ol>
<li>声明一个结点p指向链表第一个结点，初始化j从1开始；</li>
<li>当j&lt;i时，就遍历链表，让p的指针向后移动，不断指向下一结点，j累加1；</li>
<li>若到链表末尾p为空，则说明第i个元素不存在；</li>
<li>否则查找成功，返回结点p的数据。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) */</span>
<span class="cm">/* 操作结果：用e返回L中第i个数据元素的值 */</span>
<span class="n">Status</span> <span class="nf">GetElem</span><span class="p">(</span><span class="n">LinkList</span> <span class="n">L</span><span class="p">,</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">ElemType</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
    <span class="n">LinkList</span> <span class="n">p</span><span class="p">;</span>		<span class="c1">//声明一结点p
</span><span class="c1"></span>    <span class="n">p</span> <span class="o">=</span> <span class="n">L</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>	<span class="c1">//让p指向链表L的第一个结点
</span><span class="c1"></span>    <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>			<span class="c1">//j为计数器
</span><span class="c1"></span>    <span class="k">while</span><span class="p">(</span><span class="n">p</span> <span class="o">&amp;&amp;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">i</span><span class="p">)</span>	<span class="c1">//当p不为空或者计数器j还没有等于i时，循环继续
</span><span class="c1"></span>    <span class="p">{</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>	<span class="c1">//让p指向下一个结点
</span><span class="c1"></span>        <span class="o">++</span><span class="n">j</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">p</span> <span class="o">||</span> <span class="n">j</span><span class="o">&gt;</span><span class="n">i</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ERROR</span><span class="p">;</span>	<span class="c1">//第i个元素不存在
</span><span class="c1"></span>    <span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>		<span class="c1">//取第i个元素的数据
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">OK</span><span class="p">;</span>    
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="单链表的插入与删除">单链表的插入与删除</h4>
<h5 id="单链表的插入">单链表的插入</h5>
<p>单链表第i个数据插入结点的算法思路：</p>
<ol>
<li>
<p>声明一结点p指向链表第一个结点，初始化j从1开始；</p>
</li>
<li>
<p>当j&lt;i时，就遍历链表，让p的指针向后移动，不断指向下一结点，j累加1；</p>
</li>
<li>
<p>若到链表末尾p为空，则说明第i个元素不存在；</p>
</li>
<li>
<p>否则查找成功，在系统中生成一个空结点s；</p>
</li>
<li>
<p>将数据元素e赋值给<code>s-&gt;data</code>；</p>
</li>
<li>
<p>单链表的标准插入语句</p>
<p><code>s-&gt;next = p-&gt;next;</code></p>
<p><code>p-&gt;next = s;</code></p>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) */</span>
<span class="cm">/* 操作结果：在L中第i个位置之前插入新的数据元素e，L的长度加1 */</span>
<span class="n">Status</span> <span class="nf">ListInsert</span><span class="p">(</span><span class="n">LinkList</span> <span class="o">*</span><span class="n">L</span><span class="p">,</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">ElemType</span> <span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
    <span class="n">Linklist</span> <span class="n">p</span><span class="p">,</span><span class="n">s</span><span class="p">;</span>	<span class="c1">//声明一个空结点s
</span><span class="c1"></span>    <span class="n">p</span> <span class="o">=</span> <span class="o">*</span><span class="n">L</span><span class="p">;</span>			<span class="c1">//声明一结点p指向链表第一个结点
</span><span class="c1"></span>    <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">p</span> <span class="o">&amp;&amp;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">i</span><span class="p">)</span>	<span class="c1">//寻找第i个结点
</span><span class="c1"></span>    <span class="p">{</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="o">++</span><span class="n">j</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">p</span> <span class="o">||</span> <span class="n">j</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ERROR</span><span class="p">;</span>	<span class="c1">//第i个元素不存在
</span><span class="c1"></span>    <span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="n">LinkList</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Node</span><span class="p">));</span>
    <span class="cm">/* 生成新结点s */</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">OK</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h5 id="单链表的删除">单链表的删除</h5>
<p>单链表第i个数据删除结点的算法思路：</p>
<ol>
<li>声明一结点p指向链表第一个结点，初始化j从1开始；</li>
<li>当j&lt;i时，就遍历链表，让p的指针向后移动，不断指向下一结点，j累加1；</li>
<li>若到链表末尾p为空，则说明第i个元素不存在；</li>
<li>否则查找成功，将欲删除的结点<code>p-&gt;next</code>赋值给q；</li>
<li>单链表的删除标准语句<code>p-&gt;next = q-&gt;next</code>；</li>
<li>将q结点中的数据赋值给e，作为返回；</li>
<li>释放q结点；</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) */</span>
<span class="cm">/* 操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减1 */</span>
<span class="n">Status</span> <span class="nf">ListDelete</span><span class="p">(</span><span class="n">LinkList</span> <span class="o">*</span><span class="n">l</span><span class="p">,</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">ElemType</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
    <span class="n">Linklist</span> <span class="n">p</span><span class="p">,</span><span class="n">q</span><span class="p">;</span>
    <span class="n">p</span> <span class="o">=</span> <span class="o">*</span><span class="n">L</span><span class="p">;</span>
    <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">&amp;&amp;</span> <span class="n">j</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">)</span>	<span class="c1">//遍历寻找第i个元素
</span><span class="c1"></span>    <span class="p">{</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="o">++</span><span class="n">j</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="o">||</span> <span class="n">j</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ERROR</span><span class="p">;</span>	<span class="c1">//第i个元素不存在
</span><span class="c1"></span>    <span class="n">q</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>	<span class="c1">//将q的后继赋给p的后继
</span><span class="c1"></span>    <span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>		<span class="c1">//将q结点中的数据给e
</span><span class="c1"></span>    <span class="n">free</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>			<span class="c1">//回收q结点
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">OK</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="单链表结构与顺序存储结构优缺点">单链表结构与顺序存储结构优缺点</h4>
<p>简单地对单链表结构和顺序存储结构做对比：</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th>存储分配方式</th>
<th>时间性能</th>
<th>空间性能</th>
</tr>
</thead>
<tbody>
<tr>
<td>●顺序存储结构用一段连续的存储单元依次存储线性表的数据元素</td>
<td>●查找：顺序存储结构O(1)/单链表O(n)</td>
<td>●顺序存储结构需要预分配存储空间，分大了，浪费，分小了易发生上溢</td>
</tr>
<tr>
<td>●单链表采用链式存储结构，用一组任意的存储单元存放线性表的元素</td>
<td>●插入和删除：顺序存储结构需要平均移动表长一半的元素，时间为O(n)/</td>
<td>●单链表不需要分配存储空间，只要有就可以分配，元素个数也不受限制</td>
</tr>
<tr>
<td></td>
<td>单链表在线出某位置的指针后，插入和删除时间仅为O(1)</td>
<td></td>
</tr>
</tbody>
</table></div>
<h4 id="静态链表">静态链表</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* 线性表的静态链表存储结构 */</span>
<span class="cp">#define MAXSIZE 1000 </span><span class="c1">//假设链表的最大长度是1000
</span><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
    <span class="n">ElemType</span> <span class="n">data</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">cur</span><span class="p">;</span>		<span class="c1">//游标（cursor），为0时表示无指向
</span><span class="c1"></span><span class="p">}</span><span class="n">Component</span><span class="p">,</span><span class="n">StaticLinkList</span><span class="p">[</span><span class="n">MAXSIZE</span><span class="p">];</span>
</code></pre></td></tr></table>
</div>
</div><p>静态链表第一个和最后一个元素作为特殊元素处理，不存数据。未被使用的数组元素称为备用链表。而数组第一个元素，即下标为0的元素的cur；就存放备用链表的第一个结点的下标；而数组的最后一个元素的cur，则存放第一个有数值的元素的下标，相当于单链表中的头结点作用，当整个链表为空时，则为0^2^。</p>
<h5 id="初始化静态链表">初始化静态链表</h5>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* 将一维数组space中各分量链成一备用链表 */</span>
<span class="cm">/* space[0].cur为头指针，&#34;0&#34;表示空指针 */</span>
<span class="n">Status</span> <span class="nf">InitList</span><span class="p">(</span><span class="n">StaticLinkList</span> <span class="n">space</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">MAXSIZE</span><span class="o">-</span><span class="mi">1</span><span class="err">；</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">space</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cur</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">space</span><span class="p">[</span><span class="n">MAXSIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">cur</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">//目前静态链表为空，最后一个元素的cur为0
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">OK</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><img src="/p/%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9/image-20211231001030145.jpg"
	width="982"
	height="281"
	srcset="/p/%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9/image-20211231001030145_hu9bcd2e89ff491a68f4df7a897f074544_139016_480x0_resize_q75_box.jpg 480w, /p/%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9/image-20211231001030145_hu9bcd2e89ff491a68f4df7a897f074544_139016_1024x0_resize_q75_box.jpg 1024w"
	loading="lazy"
	
		alt="2"
	
	
		class="gallery-image" 
		data-flex-grow="349"
		data-flex-basis="838px"
	
></p>
<h5 id="静态链表的插入">静态链表的插入</h5>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* 若备用空间链表非空，则返回分配的结点下标，否则返回0 */</span>
<span class="cm">/* 初始化 */</span>
<span class="kt">int</span> <span class="nf">Malloc_SLL</span><span class="p">(</span><span class="n">StaticLinkList</span> <span class="n">space</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">space</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">cur</span><span class="p">;</span>
    <span class="cm">/* 当前数组第一个元素的cur存的值就是
</span><span class="cm">    要返回的第一个备用空闲的下标 */</span>
    <span class="k">if</span><span class="p">(</span><span class="n">space</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">cur</span><span class="p">)</span>
        <span class="n">space</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">cur</span> <span class="o">=</span> <span class="n">space</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cur</span><span class="p">;</span>
    <span class="cm">/* 由于要拿出一个分量使用，所以将它的下一个分量作为备用链表 */</span>
    <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* 在L中第i个元素之前插入新的数据元素e */</span>
<span class="n">Status</span> <span class="nf">ListInsert</span><span class="p">(</span><span class="n">StaticLinkList</span> <span class="n">L</span><span class="p">,</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">ElemType</span> <span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">l</span><span class="p">;</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">MAX_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/*注意k首先是最后一个元素的下标 */</span>
    <span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">1</span> <span class="o">||</span> <span class="n">i</span><span class="o">&gt;</span><span class="n">ListLength</span><span class="p">(</span><span class="n">L</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ERROR</span><span class="p">;</span>
    <span class="n">j</span> <span class="o">=</span> <span class="n">Malloc_SLL</span><span class="p">(</span><span class="n">L</span><span class="p">);</span>	<span class="cm">/*获得空闲分量的下标 */</span>
    <span class="k">if</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">L</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">data</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span> <span class="cm">/*将数据赋值给此分量的data */</span>
        <span class="k">for</span><span class="p">(</span><span class="n">l</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="n">l</span><span class="o">&lt;=</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">l</span><span class="o">++</span><span class="p">)</span> <span class="cm">/* 找到第i个元素之前的位置 */</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">cur</span><span class="p">;</span>
        <span class="n">L</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">cur</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">cur</span><span class="p">;</span>
        <span class="cm">/* 把第i个元素之前的cur赋值给新元素的cur */</span>
        <span class="n">L</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">cur</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
        <span class="cm">/* 把新元素的下标赋值给第i个元素之前的cur */</span>
        <span class="k">return</span> <span class="n">OK</span><span class="err">；</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">ERROR</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h5 id="静态链表的删除操作">静态链表的删除操作</h5>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* 删除在L中第i个数据元素e */</span>
<span class="n">Status</span> <span class="nf">ListDelete</span><span class="p">(</span><span class="n">StaticLink</span> <span class="n">L</span><span class="p">,</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">1</span> <span class="o">||</span> <span class="n">i</span><span class="o">&gt;</span> <span class="n">ListLength</span><span class="p">(</span><span class="n">L</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">ERROR</span><span class="p">;</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">MAX_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">4</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;=</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">cur</span><span class="p">;</span>
    <span class="n">j</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">cur</span><span class="p">;</span>
    <span class="n">L</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">cur</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">cur</span><span class="p">;</span>
    <span class="n">Free_SSL</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">j</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">OK</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* 将下标为k的空闲结点回收到备用链表 */</span>
<span class="kt">void</span> <span class="nf">Free_SSL</span><span class="p">(</span><span class="n">StaticLinkList</span> <span class="n">space</span><span class="p">,</span><span class="kt">int</span> <span class="n">k</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">space</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">cur</span> <span class="o">=</span> <span class="n">space</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">cur</span><span class="p">;</span>
    <span class="cm">/* 把第一个元素cur值赋给要删除的分量cur */</span>
    <span class="n">space</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">cur</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
    <span class="cm">/* 把要删除的分量下标赋值给第一个元素的cur */</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="循环链表见大话数据结构p80">循环链表（见大话数据结构P~80~）</h4>
<h4 id="双向链表">双向链表</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* 线性表的双向链表存储结构 */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">DulNode</span>
<span class="p">{</span>
    <span class="n">ELemType</span> <span class="n">data</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">DulNode</span> <span class="o">*</span><span class="n">prior</span><span class="p">;</span>
    <span class="cm">/* 前驱指针 */</span>
    <span class="k">struct</span> <span class="n">DulNode</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
    <span class="cm">/* 后继指针 */</span>
<span class="p">}</span><span class="n">DulNode</span><span class="p">,</span> <span class="o">*</span><span class="n">DuLinkList</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* 双向链表的插入 */</span>
<span class="cm">/* 先搞定插入结点的前驱和后继，
</span><span class="cm">再搞定后结点的前驱，最后解决前结点的后继 */</span>

<span class="cm">/* 双向链表的删除 */</span>
<span class="n">p</span><span class="o">-&gt;</span><span class="n">prior</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">prior</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">prior</span><span class="p">;</span>
<span class="n">free</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="栈和队列">栈和队列</h2>
<h3 id="栈">栈</h3>
<h4 id="栈的定义">栈的定义</h4>
<ol>
<li>栈是限定在表尾进行插入和删除操作的线性表。</li>
<li>插入和删除端称为栈顶，另一端为栈底。</li>
<li>栈为后进先出的线性表。</li>
</ol>
<h4 id="栈的顺序存储结构">栈的顺序存储结构</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* 栈的顺序存储表示 */</span>
<span class="cp">#define STACK_INIT_SIZE 100
</span><span class="cp">#define STACKINCREASEMENT 10;
</span><span class="cp"></span><span class="k">typedef</span> <span class="kt">int</span> <span class="n">SElemType</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span><span class="p">{</span>
    <span class="n">SElemType</span> <span class="o">*</span><span class="n">base</span><span class="p">;</span>	
    <span class="c1">//在栈构造之前和销毁之后，base的值为NULL
</span><span class="c1"></span>    <span class="n">SElemType</span> <span class="o">*</span><span class="n">top</span><span class="p">;</span>
    <span class="c1">// 栈顶指针
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">stacksize</span><span class="p">;</span>
<span class="p">}</span><span class="n">SqStack</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* 构造一个空栈 */</span>
<span class="n">Status</span> <span class="nf">InitStack</span><span class="p">(</span><span class="n">SqStack</span> <span class="o">*</span><span class="n">S</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">S</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">=</span> <span class="p">(</span><span class="n">SElemType</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">STACK_INIT_SIZE</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">SElemType</span><span class="p">));</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">S</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ERROR</span><span class="p">;</span>	<span class="c1">//存储分配失败
</span><span class="c1"></span>    <span class="n">S</span><span class="o">-&gt;</span><span class="n">top</span> <span class="o">=</span> <span class="n">S</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>
    <span class="n">S</span><span class="o">-&gt;</span><span class="n">stacksize</span> <span class="o">=</span> <span class="n">STACK_INIT_SIZE</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">OK</span><span class="p">;</span>    
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* 销毁栈 */</span>
<span class="n">Status</span> <span class="nf">DestoryStack</span><span class="p">(</span><span class="n">SqStack</span> <span class="o">*</span><span class="n">S</span><span class="p">)</span>
<span class="p">{</span>   
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">S</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ERROR</span><span class="p">;</span>
    <span class="n">free</span><span class="p">(</span><span class="n">S</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">);</span>
    <span class="n">S</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">S</span><span class="o">-&gt;</span><span class="n">top</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">S</span><span class="o">-&gt;</span><span class="n">stacksize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">OK</span><span class="p">;</span>    
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* 把栈S置为空栈 */</span>
<span class="n">Status</span> <span class="nf">ClearStack</span><span class="p">(</span><span class="n">SqStack</span> <span class="o">*</span><span class="n">S</span><span class="p">)</span>
<span class="p">{</span>   
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">S</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ERROR</span><span class="p">;</span>
     <span class="n">S</span><span class="o">-&gt;</span><span class="n">top</span> <span class="o">=</span> <span class="n">S</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">OK</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* 如果栈为空则返回TRUE，否则返回FALSE */</span>
<span class="n">Status</span> <span class="nf">StackEmpty</span><span class="p">(</span><span class="n">SqStack</span> <span class="o">*</span><span class="n">S</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">S</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ERROR</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">S</span><span class="o">-&gt;</span><span class="n">top</span> <span class="o">==</span> <span class="n">S</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
    <span class="k">else</span> 
        <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* 返回栈的长度 */</span>
<span class="kt">int</span> <span class="nf">StackLength</span><span class="p">(</span><span class="n">SqStack</span> <span class="o">*</span><span class="n">S</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">S</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ERROR</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">S</span><span class="o">-&gt;</span><span class="n">top</span> <span class="o">-</span> <span class="n">S</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* 若栈不为空，则用e返回S的栈顶元素，并返回OK,否则返回ERROR */</span>
<span class="n">Status</span> <span class="nf">GetTop</span><span class="p">(</span><span class="n">SqStack</span> <span class="o">*</span><span class="n">S</span><span class="p">,</span> <span class="n">SElemType</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">S</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">||</span> <span class="n">S</span><span class="o">-&gt;</span><span class="n">top</span> <span class="o">==</span> <span class="n">S</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">)</span> 
        <span class="k">return</span> <span class="n">ERROR</span><span class="p">;</span>
    <span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">S</span><span class="o">-&gt;</span><span class="n">top</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">OK</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* 插入元素e为新的栈顶 */</span>
<span class="n">Status</span> <span class="nf">Push</span><span class="p">(</span><span class="n">SqStack</span> <span class="o">*</span><span class="n">S</span><span class="p">,</span> <span class="n">SElemType</span> <span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* 栈满，追加存储空间 */</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">S</span><span class="o">-&gt;</span><span class="n">top</span> <span class="o">-</span> <span class="n">S</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">&gt;=</span> <span class="n">S</span><span class="o">-&gt;</span><span class="n">stacksize</span> <span class="p">)</span> 
    <span class="p">{</span>
        <span class="n">SElemType</span> <span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="n">SElemType</span> <span class="o">*</span><span class="p">)</span><span class="n">realloc</span><span class="p">(</span> <span class="n">S</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span>
            <span class="p">(</span><span class="n">S</span><span class="o">-&gt;</span><span class="n">stacksize</span> <span class="o">+</span> <span class="n">STACK_INCREMENT</span><span class="p">)</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="n">SElemType</span><span class="p">)</span> <span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">ptr</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">ERROR</span><span class="p">;</span>
        <span class="n">S</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>
        <span class="n">S</span><span class="o">-&gt;</span><span class="n">top</span> <span class="o">=</span> <span class="n">S</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">S</span><span class="o">-&gt;</span><span class="n">stacksize</span><span class="p">;</span> 
        <span class="cm">/* top重新指向新的地址 */</span>
        <span class="n">S</span><span class="o">-&gt;</span><span class="n">stacksize</span> <span class="o">+=</span> <span class="n">STACK_INCREMENT</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="o">*</span><span class="p">(</span><span class="n">S</span><span class="o">-&gt;</span><span class="n">top</span><span class="p">)</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span>
    <span class="n">S</span><span class="o">-&gt;</span><span class="n">top</span><span class="o">++</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">OK</span><span class="p">;</span>    
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* 若栈不空，则弹出栈顶元素，用e保存返回值 */</span>
<span class="n">Status</span> <span class="nf">Pop</span><span class="p">(</span><span class="n">SqStack</span> <span class="o">*</span><span class="n">S</span><span class="p">,</span><span class="n">SElemType</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">S</span><span class="o">-&gt;</span><span class="n">top</span> <span class="o">==</span> <span class="n">S</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">)</span> <span class="cm">/* 栈空了 */</span>
        <span class="k">return</span> <span class="n">ERROR</span><span class="p">;</span>
    <span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">S</span><span class="o">-&gt;</span><span class="n">top</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">S</span><span class="o">-&gt;</span><span class="n">top</span><span class="o">--</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">OK</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* 从栈顶往下打印栈中的数据 */</span>
<span class="kt">void</span> <span class="nf">printSqStack</span><span class="p">(</span><span class="n">SqStack</span> <span class="o">*</span><span class="n">S</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">SElemType</span> <span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">S</span><span class="o">-&gt;</span><span class="n">top</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="n">S</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%d &#34;</span><span class="p">,</span><span class="o">*</span><span class="p">(</span><span class="n">p</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
        <span class="n">p</span><span class="o">--</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="栈的链式存储结构略">栈的链式存储结构（略）</h4>
<h3 id="队列">队列</h3>
<h4 id="队列的定义">队列的定义</h4>
<ol>
<li>队列是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。</li>
<li>队列是一种先进先出的线性表。</li>
<li>允许插入的一端称为队尾，允许删除的一端称为队头。</li>
</ol>
<h4 id="链队列">链队列</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* 队列的链式存储结构 */</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="n">QElemType</span><span class="p">;</span>
<span class="cm">/* 结点 */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">QNode</span>
<span class="p">{</span>
    <span class="n">QElemType</span> <span class="n">data</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">QNode</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span><span class="n">QNode</span><span class="p">,</span><span class="o">*</span><span class="n">QueuePtr</span><span class="p">;</span>
<span class="cm">/* 链表结构 */</span>
<span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
    <span class="n">QueuePtr</span> <span class="n">front</span><span class="p">;</span>	<span class="c1">//队头指针
</span><span class="c1"></span>    <span class="n">QueuePtr</span> <span class="n">rear</span><span class="p">;</span>	<span class="c1">//队尾指针
</span><span class="c1"></span><span class="p">}</span><span class="n">LinkQueue</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* 插入元素e为Q的新的队尾元素 */</span>
<span class="n">Status</span> <span class="nf">EnQueue</span><span class="p">(</span><span class="n">LinkQueue</span> <span class="o">*</span><span class="n">Q</span><span class="p">,</span><span class="n">QElemType</span> <span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">QueuePtr</span> <span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="n">QueuePtr</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">QNode</span><span class="p">));</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ERROR</span><span class="p">;</span>
    <span class="cm">/* 存储分配失败 */</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">Q</span><span class="o">-&gt;</span><span class="n">rear</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
    <span class="cm">/* 把拥有元素e的新结点s赋值给原队尾结点的后继 */</span>
    <span class="n">Q</span><span class="o">-&gt;</span><span class="n">rear</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
    <span class="cm">/* 把当前的s设置为队尾结点，rear指向s */</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* 若队列不空，删除Q的队头元素，用e返回其值，并返回OK，否则ERROR */</span>
<span class="n">Status</span> <span class="nf">DeQueue</span><span class="p">(</span><span class="n">LinkQueue</span> <span class="o">*</span><span class="n">Q</span><span class="p">,</span><span class="n">QElemType</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">QueuePtr</span> <span class="n">p</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">Q</span><span class="o">-&gt;</span><span class="n">front</span> <span class="o">==</span> <span class="n">Q</span><span class="o">-&gt;</span><span class="n">rear</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ERROR</span><span class="p">;</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">Q</span><span class="o">-&gt;</span><span class="n">front</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="c1">//将欲删除的队头结点暂存于p
</span><span class="c1"></span>    <span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
    <span class="c1">//将欲删除的队头结点的值赋给e
</span><span class="c1"></span>    <span class="n">Q</span><span class="o">-&gt;</span><span class="n">front</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="c1">//将原队头结点后继p-&gt;next赋值给头结点后继
</span><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">Q</span><span class="o">-&gt;</span><span class="n">rear</span> <span class="o">==</span> <span class="n">p</span><span class="p">)</span>	<span class="c1">//若队头是队尾，则删除后将rear指向头结点
</span><span class="c1"></span>        <span class="n">Q</span><span class="o">-&gt;</span><span class="n">rear</span> <span class="o">=</span> <span class="n">Q</span><span class="o">-&gt;</span><span class="n">front</span><span class="p">;</span>
    <span class="n">free</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">OK</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="循环队列">循环队列</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* 队列的顺式存储结构 */</span>
<span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
    <span class="n">QElemType</span> <span class="o">*</span> <span class="n">base</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">front</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">rear</span><span class="p">;</span>
<span class="p">}</span><span class="n">SqQueue</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* 循环队列初始化 */</span>
<span class="n">Status</span> <span class="nf">InitQueue</span><span class="p">(</span><span class="n">SqQueue</span> <span class="o">*</span><span class="n">Q</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Q</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">=</span> <span class="p">(</span><span class="n">QElemType</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">QElemType</span><span class="p">)</span><span class="o">*</span><span class="n">MAX_SIZE</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">Q</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>     <span class="c1">//队列内存分配成功
</span><span class="c1"></span>    <span class="p">{</span>
        <span class="n">Q</span><span class="o">-&gt;</span><span class="n">front</span> <span class="o">=</span> <span class="n">Q</span><span class="o">-&gt;</span><span class="n">rear</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//初始化头尾指针
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="k">return</span> <span class="n">OK</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* 入队 */</span>
<span class="kt">void</span> <span class="nf">EnQueue</span><span class="p">(</span><span class="n">SqQueue</span> <span class="o">*</span><span class="n">Q</span> <span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">((</span><span class="n">Q</span><span class="o">-&gt;</span><span class="n">rear</span> <span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">MAX_SIZE</span> <span class="o">==</span> <span class="n">Q</span><span class="o">-&gt;</span><span class="n">front</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ERROR</span><span class="p">;</span>
    <span class="c1">//队列满
</span><span class="c1"></span>    <span class="p">{</span>
        <span class="n">Q</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">[</span><span class="n">Q</span><span class="o">-&gt;</span><span class="n">rear</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
        <span class="n">Q</span><span class="o">-&gt;</span><span class="n">rear</span> <span class="o">=</span> <span class="p">(</span><span class="n">Q</span><span class="o">-&gt;</span><span class="n">rear</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">MAX_SIZE</span> <span class="p">;</span>    <span class="c1">//尾指针偏移
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* 出队 */</span>
<span class="kt">void</span> <span class="nf">DeQueue</span><span class="p">(</span><span class="n">SqQueue</span> <span class="o">*</span><span class="n">Q</span> <span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">value</span><span class="p">)</span>
 <span class="p">{</span>
     <span class="k">if</span><span class="p">(</span><span class="n">Q</span><span class="o">-&gt;</span><span class="n">front</span> <span class="o">==</span> <span class="n">Q</span><span class="o">-&gt;</span><span class="n">rear</span><span class="p">)</span>        <span class="c1">//队列空
</span><span class="c1"></span>         <span class="k">return</span> <span class="n">ERROR</span><span class="p">;</span>
     <span class="p">{</span>
        <span class="o">*</span><span class="n">value</span> <span class="o">=</span> <span class="n">Q</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">[</span><span class="n">Q</span><span class="o">-&gt;</span><span class="n">front</span><span class="p">];</span>
        <span class="n">Q</span><span class="o">-&gt;</span><span class="n">front</span> <span class="o">=</span> <span class="p">(</span><span class="n">Q</span><span class="o">-&gt;</span><span class="n">front</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">MAX_SIZE</span> <span class="p">;</span>
     <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="串">串</h2>
<h3 id="串的定义略">串的定义（略）</h3>
<ul>
<li>
<p><strong>串</strong>是由零个或多个字符组成的有限序列。</p>
</li>
<li>
<p>串中字符的个数称为串的<strong>长度</strong>。</p>
</li>
<li>
<p>含有零个字符的串叫<strong>空串</strong>。</p>
</li>
<li>
<p>串中任意个连续的字符组成的子序列称为该串的<strong>子串</strong>。</p>
</li>
<li>
<p>包含字串的串称为<strong>主串</strong>，某个字符在串中的序号称为这个字符的<strong>位置</strong>。</p>
</li>
<li>
<p>串是限定了元素为字符的线性表。</p>
</li>
<li>
<p>当且仅当两个串的值相等，两个串<strong>相等</strong>。</p>
</li>
<li>
<p>有一个或多个空格组成的串' &lsquo;称为<strong>空格串</strong>。<em>空格串不是空串</em>。</p>
</li>
<li>
<p>对<strong>C语言</strong>来讲，串主要由一个字符数组表示，字符串<strong>str</strong>中的字符有 &lsquo;a&rsquo; ,&rsquo;s&rsquo;, &lsquo;1&rsquo;,&lsquo;2&rsquo;,&lsquo;3&rsquo;,'\0'。'\0&rsquo;是转译字符，意思是告诉编译器，这不是字符0，而是空字符，是字符串的<strong>结束标志</strong>。</p>
<p>故<strong>字符数组str</strong>的<strong>长度为7</strong>，而<strong>串str</strong>的<strong>长度为6</strong></p>
</li>
</ul>
<h2 id="数组和广义表">数组和广义表</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="kt">int</span> <span class="n">Status</span><span class="p">;</span>
<span class="cp">#define MAXSTRLEN 255</span><span class="c1">//可在255以内定义最大串长
</span><span class="c1"></span><span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">SString</span><span class="p">[</span><span class="n">MAXSTRLEN</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
<span class="c1">//0号单元存放串长
</span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#define MAXSIZE 1024
</span><span class="cp"></span>
<span class="c1">//串的定长顺序储存结构
</span><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_str</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="n">str</span><span class="p">[</span><span class="n">MAXSIZE</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">length</span><span class="p">;</span>
<span class="p">}</span><span class="n">Str</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="c1">//串的变长储存结构
</span><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_str_p</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">ch</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">length</span><span class="p">;</span>
<span class="p">}</span><span class="n">Str_p</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="c1">//先定义一个串的结构体
</span><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_str_p</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">ch</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">length</span><span class="p">;</span>
<span class="p">}</span><span class="n">Str_p</span><span class="p">;</span>

<span class="c1">//定义一个串
</span><span class="c1"></span><span class="n">Str_p</span> <span class="n">str</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* 串的初始化 */</span>
<span class="kt">bool</span> <span class="nf">initStr</span><span class="p">(</span><span class="n">Str_p</span> <span class="o">&amp;</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">str</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">str</span><span class="p">.</span><span class="n">ch</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* 串的赋值 */</span>
<span class="c1">//参数：串， 串的内容
</span><span class="c1"></span><span class="kt">bool</span> <span class="nf">inputString</span><span class="p">(</span><span class="n">Str_p</span> <span class="o">&amp;</span><span class="n">str</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">ch</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">str</span><span class="p">.</span><span class="n">ch</span><span class="p">)</span> <span class="n">free</span><span class="p">(</span><span class="n">str</span><span class="p">.</span><span class="n">ch</span><span class="p">);</span>

    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">ch</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="o">*</span><span class="n">c</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="o">++</span><span class="n">len</span><span class="p">;</span>
        <span class="c1">//因为内存连续，所以可以对c进行自增
</span><span class="c1"></span>        <span class="o">++</span><span class="n">c</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="c1">//若赋值为空，即该串为空串
</span><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">len</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">str</span><span class="p">.</span><span class="n">ch</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span>
        <span class="n">str</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="c1">//len+1是为了存放&#39;\0&#39;
</span><span class="c1"></span>        <span class="n">str</span><span class="p">.</span><span class="n">ch</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">len</span><span class="o">+</span><span class="mi">1</span><span class="p">));</span>
        
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">str</span><span class="p">.</span><span class="n">ch</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">ch</span><span class="p">;</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span><span class="n">c</span><span class="o">++</span><span class="p">)</span>
                <span class="n">str</span><span class="p">.</span><span class="n">ch</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
            <span class="n">str</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>        
    <span class="p">}</span>    
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* 获取串的长度 */</span>
<span class="kt">int</span> <span class="nf">getStrLen</span><span class="p">(</span><span class="n">Str_p</span> <span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">str</span><span class="p">.</span><span class="n">length</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* 串的比较 */</span>
<span class="kt">int</span> <span class="nf">strCompare</span><span class="p">(</span><span class="n">Str_p</span> <span class="n">s1</span><span class="p">,</span> <span class="n">Str_p</span> <span class="n">s2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">s1</span><span class="p">.</span><span class="n">length</span> <span class="o">&amp;&amp;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">s2</span><span class="p">.</span><span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="k">if</span><span class="p">(</span><span class="n">s1</span><span class="p">.</span><span class="n">ch</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">!=</span><span class="n">s2</span><span class="p">.</span><span class="n">ch</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">s1</span><span class="p">.</span><span class="n">ch</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">s2</span><span class="p">.</span><span class="n">ch</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="k">return</span> <span class="n">s1</span><span class="p">.</span><span class="n">length</span> <span class="o">-</span> <span class="n">s2</span><span class="p">.</span><span class="n">length</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* 合并串 */</span>
<span class="c1">//参数： 合并后的字符串， 子串1， 子串2
</span><span class="c1"></span><span class="kt">bool</span> <span class="nf">conStr</span><span class="p">(</span><span class="n">Str_p</span> <span class="o">&amp;</span><span class="n">str</span><span class="p">,</span> <span class="n">Str_p</span> <span class="n">s1</span><span class="p">,</span> <span class="n">Str_p</span> <span class="n">s2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">initStr</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">str</span><span class="p">.</span><span class="n">ch</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">free</span><span class="p">(</span><span class="n">str</span><span class="p">.</span><span class="n">ch</span><span class="p">);</span>
        <span class="n">str</span><span class="p">.</span><span class="n">ch</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="n">str</span><span class="p">.</span><span class="n">ch</span> <span class="o">=</span>
    <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">s1</span><span class="p">.</span><span class="n">length</span><span class="o">+</span><span class="n">s2</span><span class="p">.</span><span class="n">length</span><span class="o">+</span><span class="mi">1</span><span class="p">));</span>
    
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">str</span><span class="p">.</span><span class="n">ch</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    
    <span class="c1">//将s1的字符保存到str
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">s1</span><span class="p">.</span><span class="n">length</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">str</span><span class="p">.</span><span class="n">ch</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">s1</span><span class="p">.</span><span class="n">ch</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    
    <span class="c1">//同理
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
    <span class="c1">//此处取等号是为了把&#39;\0&#39;放进去
</span><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;=</span><span class="n">s2</span><span class="p">.</span><span class="n">length</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
        <span class="n">str</span><span class="p">.</span><span class="n">ch</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">s2</span><span class="p">.</span><span class="n">ch</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
    
    <span class="n">str</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">s1</span><span class="p">.</span><span class="n">length</span> <span class="o">+</span> <span class="n">s2</span><span class="p">.</span><span class="n">length</span><span class="p">;</span>   
    
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* 求子串 */</span>
<span class="c1">//参数： 子串， 父串， 起始位置， 切片长度
</span><span class="c1"></span><span class="kt">bool</span> <span class="nf">subStr</span><span class="p">(</span><span class="n">Str_p</span> <span class="o">&amp;</span><span class="n">substr</span><span class="p">,</span><span class="n">Str_p</span> <span class="n">str</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">initStr</span><span class="p">(</span><span class="n">substr</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">pos</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">||</span>
       <span class="n">pos</span><span class="o">&gt;</span><span class="n">str</span><span class="p">.</span><span class="n">length</span><span class="o">||</span>
       <span class="n">len</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">||</span>
       <span class="n">len</span><span class="o">&gt;</span><span class="n">str</span><span class="p">.</span><span class="n">length</span><span class="o">-</span><span class="n">pos</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">substr</span><span class="p">.</span><span class="n">ch</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">free</span><span class="p">(</span><span class="n">substr</span><span class="p">.</span><span class="n">ch</span><span class="p">);</span>
        <span class="n">substr</span><span class="p">.</span><span class="n">ch</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="c1">//所求子串为空串
</span><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">len</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">substr</span><span class="p">.</span><span class="n">ch</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span>
        <span class="n">substr</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span><span class="p">{</span>
        <span class="n">substr</span><span class="p">.</span><span class="n">ch</span> <span class="o">=</span>
        <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">len</span><span class="o">+</span><span class="mi">1</span><span class="p">));</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">pos</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;</span><span class="n">pos</span><span class="o">+</span><span class="n">len</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">substr</span><span class="p">.</span><span class="n">ch</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">str</span><span class="p">.</span><span class="n">ch</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="n">i</span><span class="o">++</span><span class="p">;</span>
            <span class="n">j</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        
        <span class="n">substr</span><span class="p">.</span><span class="n">ch</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
        <span class="n">substr</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
        
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
    
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* 清空串 */</span>
<span class="kt">bool</span> <span class="nf">clearStr</span><span class="p">(</span><span class="n">Str_p</span> <span class="o">&amp;</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">str</span><span class="p">.</span><span class="n">ch</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">free</span><span class="p">(</span><span class="n">str</span><span class="p">.</span><span class="n">ch</span><span class="p">);</span>
        <span class="n">str</span><span class="p">.</span><span class="n">ch</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">str</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="树和二叉树">树和二叉树</h2>
<h3 id="树的定义">树的定义</h3>
<ol>
<li><strong>节点的度</strong>：一个节点含有的子树的个数称为该节点的度；</li>
<li><strong>树的度</strong>：一棵树中，最大的节点度称为树的度；</li>
<li><strong>叶节点</strong>或<strong>终端节点</strong>：度为零的节点；</li>
<li><strong>非终端节点</strong>或<strong>分支节点</strong>：度不为零的节点；</li>
<li><strong>父亲节点</strong>或<strong>父节点</strong>：若一个节点含有子节点，则这个节点称为其子节点的父节点；</li>
<li><strong>孩子节点</strong>或<strong>子节点</strong>：一个节点含有的子树的根节点称为该节点的子节点；</li>
<li><strong>兄弟节点</strong>：具有相同父节点的节点互称为兄弟节点；</li>
<li>节点的<strong>层次</strong>：从根开始定义起，根为第1层，根的子节点为第2层，以此类推；</li>
<li><strong>深度</strong>：对于任意节点n,n的深度为从根到n的唯一路径长，根的深度为0；</li>
<li><strong>高度</strong>：对于任意节点n,n的高度为从n到一片树叶的最长路径长，所有树叶的高度为0；</li>
<li><strong>堂兄弟节点</strong>：父节点在同一层的节点互为堂兄弟；</li>
<li><strong>节点的祖先</strong>：从根到该节点所经分支上的所有节点；</li>
<li><strong>子孙</strong>：以某节点为根的子树中任一节点都称为该节点的子孙。</li>
<li><strong>森林</strong>：由m（m&gt;=0）棵互不相交的树的集合称为森林；</li>
</ol>
<h3 id="树的种类">树的种类</h3>
<ul>
<li>无序树：树中任意节点的子节点之间没有顺序关系，这种树称为无序树，也称为自由树。</li>
<li>有序树：树中任意节点的子节点之间有顺序关系，这种树称为有序树；
<ul>
<li>二叉树：每个节点最多含有两个子树的树称为二叉树；
<ul>
<li>完全二叉树：对于一棵二叉树，假设其深度为d（d&gt;1）。除了第d层外，其它各层的节点数目均已达最大值，且第d层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树；
<ul>
<li>满二叉树：所有叶节点都在最底层的完全二叉树；</li>
</ul>
</li>
<li>平衡二叉树（AVL树）：当且仅当任何节点的两棵子树的高度差不大于1的二叉树；</li>
<li>排序二叉树(二叉查找树)（英语：Binary Search Tree))：也称二叉搜索树、有序二叉树；</li>
</ul>
</li>
<li>霍夫曼树：带权路径最短的二叉树称为哈夫曼树或最优二叉树；</li>
<li>B树：一种对读写操作进行优化的自平衡的二叉查找树，能够保持数据有序，拥有多于两个子树。</li>
</ul>
</li>
</ul>
<h3 id="树的存储结构">树的存储结构</h3>
<h4 id="双亲表示法">双亲表示法</h4>
<p><img src="/p/%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9/Sqll.jpg"
	width="465"
	height="300"
	srcset="/p/%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9/Sqll_hu6aa2c001b467801f1a42ac62b983220e_109699_480x0_resize_q75_box.jpg 480w, /p/%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9/Sqll_hu6aa2c001b467801f1a42ac62b983220e_109699_1024x0_resize_q75_box.jpg 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="155"
		data-flex-basis="372px"
	
></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* 树的双亲表示法结点结构定义 */</span>
<span class="cp">#define MAX_TREE_SIZE 100
</span><span class="cp"></span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="n">TElemType</span><span class="p">;</span>
<span class="cm">/* 树结点的数据类型，目前暂定为整型 */</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">PTNode</span>				<span class="cm">/* 结点结构 */</span>
<span class="p">{</span>
	<span class="n">TElemType</span> <span class="n">data</span><span class="p">;</span>					<span class="cm">/* 结点数据 */</span>
	<span class="kt">int</span> <span class="n">parent</span><span class="p">;</span>						<span class="cm">/* 双亲位置 */</span>
<span class="p">}</span> <span class="n">PTNode</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span>						<span class="cm">/* 树结构 */</span>
<span class="p">{</span>
	<span class="n">PTNode</span> <span class="n">nodes</span><span class="p">[</span><span class="n">MAX_TREE_SIZE</span><span class="p">];</span>	<span class="cm">/* 结点数组 */</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">,</span><span class="n">n</span><span class="p">;</span>						<span class="cm">/* 根的位置和结点数 */</span>
<span class="p">}</span> <span class="n">PTree</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="孩子表示法">孩子表示法</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* 树的孩子表示法结构定义 */</span>
<span class="cp">#define MAX_TREE_SIZE 100
</span><span class="cp"></span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="n">TElemType</span><span class="p">;</span>			<span class="cm">/* 树结点的数据类型，目前暂定为整型 */</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">CTNode</span>			<span class="cm">/* 孩子结点 */</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">child</span><span class="p">;</span>	
	<span class="k">struct</span> <span class="n">CTNode</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>	
<span class="p">}</span> <span class="o">*</span><span class="n">ChildPtr</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> 					<span class="cm">/* 表头结构 */</span>
<span class="p">{</span>
	<span class="n">TElemType</span> <span class="n">data</span><span class="p">;</span>	
	<span class="n">ChildPtr</span> <span class="n">firstchild</span><span class="p">;</span>	
<span class="p">}</span> <span class="n">CTBox</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span>	     			<span class="cm">/* 树结构 */</span>
<span class="p">{</span>
	<span class="n">CTBox</span> <span class="n">nodes</span><span class="p">[</span><span class="n">MAX_TREE_SIZE</span><span class="p">];</span>	<span class="cm">/* 结点数组 */</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">,</span><span class="n">n</span><span class="p">;</span>					<span class="cm">/* 根的位置和结点数 */</span>
<span class="p">}</span> <span class="n">CTree</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="孩子兄弟表示法">孩子兄弟表示法</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* 树的左孩子右兄弟表示法结构定义 */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">CSNode</span>
<span class="p">{</span>
	<span class="n">TElemType</span> <span class="n">data</span><span class="p">;</span>	
	<span class="k">struct</span> <span class="n">CSNode</span> <span class="o">*</span><span class="n">firstchild</span><span class="p">,</span><span class="o">*</span><span class="n">rightsib</span><span class="p">;</span>	
<span class="p">}</span> <span class="n">CSNode</span><span class="p">,</span><span class="o">*</span><span class="n">CSTree</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="二叉树">二叉树</h3>
<h4 id="二叉树的定义与特点">二叉树的定义与特点</h4>
<p><strong>二叉树</strong>：是n（n&gt;=0）个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成。</p>
<p><strong>二叉树的特点</strong>：</p>
<ul>
<li>每个结点最多两个子树，所以二叉树中不存在度大于2的结点。注意不是只有两棵子树，而是最多有。没有子树或者有一棵子树都是可以的。</li>
<li>左子树和右子树是有顺序的，次序不能任意颠倒。</li>
<li>即使树中的某结点只有一棵子树，也要区分它是左子树还是右子树。</li>
</ul>
<h4 id="二叉树的性质">二叉树的性质</h4>
<ol>
<li>在二叉树的第i层上至多有2^i-1^个结点（i&gt;=1）。</li>
<li>深度为k的二叉树最多有2^k-1^个结点（k&gt;=1）。</li>
<li>对任何一棵二叉树T，如果其终端结点数为n~0~，度为2的结点数为n~2~，则n~0~=n~2~+1。</li>
<li>具有n个结点的完全二叉树的深度为 ⌊log~2~(n)⌋+1 。</li>
<li>对于任意一个完全二叉树来说，如果将含有的结点按照层次从左到右依次标号，对于任意一个结点 i ，完全二叉树还有以下3个结论成立：
<ul>
<li>当 i&gt;1 时，父亲结点为结点 ⌊i/2⌋ 。（i=1 时，表示的是根结点，无双亲结点）</li>
<li>如果 2×i&gt;n（总结点的个数） ，则结点 i 肯定没有左孩子（为叶子结点）；否则其左孩子是结点 2×i 。</li>
<li>如果 2×i+1&gt;n ，则结点 i 肯定没有右孩子；否则右孩子是结点 2×i+1。</li>
</ul>
</li>
</ol>
<h4 id="二叉树的顺式存储结构">二叉树的顺式存储结构</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* 二叉树的顺序存储表示 */</span>
<span class="cp">#define MAX_TREE_SIZE 100 </span><span class="cm">/* 二叉树的最大节点数 */</span><span class="cp">
</span><span class="cp"></span><span class="k">typedef</span> <span class="n">TElemType</span> <span class="n">SqBiTree</span><span class="p">[</span><span class="n">MAX_TREE_SIZE</span><span class="p">];</span> 
<span class="cm">/* 0号单元存储根节点 */</span>
<span class="n">SqBiTree</span> <span class="n">bt</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">level</span><span class="p">,</span><span class="n">order</span><span class="p">;</span> <span class="cm">/* 即节点的层(按[满二叉树]计算) */</span>
<span class="p">}</span><span class="n">position</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="二叉树的链式存储结构">二叉树的链式存储结构</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* 二叉树的二叉链表存储表示 */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">BiTNode</span>
 <span class="p">{</span>
   <span class="n">TElemType</span> <span class="n">data</span><span class="p">;</span>
   <span class="k">struct</span> <span class="n">BiTNode</span> <span class="o">*</span><span class="n">lchild</span><span class="p">,</span><span class="o">*</span><span class="n">rchild</span><span class="p">;</span> <span class="cm">/* 左右孩子指針 */</span>
 <span class="p">}</span><span class="n">BiTNode</span><span class="p">,</span><span class="o">*</span><span class="n">BiTree</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="二叉树的遍历">二叉树的遍历</h4>
<h5 id="前序遍历">前序遍历</h5>
<p>先序遍历二叉树的操作为：</p>
<ol>
<li>访问根结点</li>
<li>先序遍历左子树</li>
<li>先序遍历右子树</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* 二叉树的前序遍历递归算法 */</span>
<span class="cm">/* 初始条件: 二叉树T存在 */</span>
<span class="cm">/* 操作结果: 前序递归遍历T */</span>
<span class="kt">void</span> <span class="nf">PreOrderTraverse</span><span class="p">(</span><span class="n">BiTree</span> <span class="n">T</span><span class="p">)</span>
<span class="p">{</span> 
	<span class="k">if</span><span class="p">(</span><span class="n">T</span><span class="o">==</span><span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">&#34;%c&#34;</span><span class="p">,</span><span class="n">T</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>		
    <span class="cm">/* 显示结点数据，可以更改为其它对结点操作 */</span>
	<span class="n">PreOrderTraverse</span><span class="p">(</span><span class="n">T</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">);</span><span class="cm">/* 再先序遍历左子树 */</span>
	<span class="n">PreOrderTraverse</span><span class="p">(</span><span class="n">T</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">);</span><span class="cm">/* 最后先序遍历右子树 */</span>
</code></pre></td></tr></table>
</div>
</div><p><img src="/p/%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9/Sorted_binary_tree_preorder.svg"
	
	
	
	loading="lazy"
	
		alt="5"
	
	
></p>
<h5 id="中序遍历">中序遍历</h5>
<p>中序遍历二叉树的操作为：</p>
<ol>
<li>中序遍历左子树</li>
<li>访问根结点</li>
<li>中序遍历右子树</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* 二叉树的中序遍历递归算法 */</span>
<span class="cm">/* 初始条件: 二叉树T存在 */</span>
<span class="cm">/* 操作结果: 中序递归遍历T */</span>
<span class="kt">void</span> <span class="nf">InOrderTraverse</span><span class="p">(</span><span class="n">BiTree</span> <span class="n">T</span><span class="p">)</span>
<span class="p">{</span> 
	<span class="k">if</span><span class="p">(</span><span class="n">T</span><span class="o">==</span><span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">InOrderTraverse</span><span class="p">(</span><span class="n">T</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">);</span> <span class="cm">/* 中序遍历左子树 */</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">&#34;%c&#34;</span><span class="p">,</span><span class="n">T</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>		<span class="cm">/* 显示结点数据，可以更改为其它对结点操作 */</span>
	<span class="n">InOrderTraverse</span><span class="p">(</span><span class="n">T</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">);</span> <span class="cm">/* 最后中序遍历右子树 */</span>
</code></pre></td></tr></table>
</div>
</div><p><img src="/p/%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9/Sorted_binary_tree_inorder.svg"
	
	
	
	loading="lazy"
	
	
></p>
<h5 id="后序遍历">后序遍历</h5>
<p>后序遍历二叉树的操作为：</p>
<ol>
<li>后序遍历左子树</li>
<li>后序遍历右子树</li>
<li>访问根结点</li>
</ol>
<p><img src="/p/%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9/Sorted_binary_tree_postorder.svg"
	
	
	
	loading="lazy"
	
	
></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="o">*</span> <span class="err">二叉树的后序遍历递归算法</span> <span class="err">*/</span>
<span class="cm">/* 初始条件: 二叉树T存在 */</span>
<span class="cm">/* 操作结果: 后序递归遍历T */</span>
<span class="kt">void</span> <span class="n">PostOrderTraverse</span><span class="p">(</span><span class="n">BiTree</span> <span class="n">T</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span><span class="p">(</span><span class="n">T</span><span class="o">==</span><span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">PostOrderTraverse</span><span class="p">(</span><span class="n">T</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">);</span> 	<span class="cm">/* 先后序遍历左子树  */</span>
	<span class="n">PostOrderTraverse</span><span class="p">(</span><span class="n">T</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">);</span> 	<span class="cm">/* 再后序遍历右子树  */</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">&#34;%c&#34;</span><span class="p">,</span><span class="n">T</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>			<span class="cm">/* 显示结点数据，可以更改为其它对结点操作 */</span>
</code></pre></td></tr></table>
</div>
</div><h5 id="广度优先遍历">广度优先遍历</h5>
<p><img src="/p/%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9/Sorted_binary_tree_breadth-first_traversal.svg"
	
	
	
	loading="lazy"
	
	
></p>
<h4 id="线索二叉树">线索二叉树</h4>
<p><strong>线索二叉树</strong>(引线二叉树) 的定义如下：</p>
<p>“一个二叉树通过如下的方法“穿起来”：所有原本为空的右(孩子)指针改为指向该节点在中序序列中的后继，所有原本为空的左(孩子)指针改为指向该节点的中序序列的前驱。”</p>
<p><img src="/p/%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9/Threaded_tree.svg"
	
	
	
	loading="lazy"
	
	
></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* 二叉树的二叉线索存储结构定义 */</span>
<span class="k">typedef</span> <span class="kt">char</span> <span class="n">TElemType</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span><span class="n">Link</span><span class="p">,</span><span class="n">Thread</span><span class="p">}</span> <span class="n">PointerTag</span><span class="p">;</span>	
<span class="cm">/* Link==0 表示指向左右孩子指针, */</span>
<span class="cm">/* Thread==1 表示指向前驱或后继的线索 */</span>
<span class="k">typedef</span>  <span class="k">struct</span> <span class="n">BiThrNode</span>		<span class="cm">/* 二叉线索存储结点结构 */</span>
<span class="p">{</span>
	<span class="n">TElemType</span> <span class="n">data</span><span class="p">;</span>				<span class="cm">/* 结点数据 */</span>
	<span class="k">struct</span> <span class="n">BiThrNode</span> <span class="o">*</span><span class="n">lchild</span><span class="p">,</span> <span class="o">*</span><span class="n">rchild</span><span class="p">;</span>	<span class="cm">/* 左右孩子指针 */</span>
	<span class="n">PointerTag</span> <span class="n">LTag</span><span class="p">;</span>
	<span class="n">PointerTag</span> <span class="n">RTag</span><span class="p">;</span>					<span class="cm">/* 左右标志 */</span>
<span class="p">}</span> <span class="n">BiThrNode</span><span class="p">,</span> <span class="o">*</span><span class="n">BiThrTree</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">BiThrTree</span> <span class="n">pre</span><span class="p">;</span>
<span class="cm">/* 全局变量,始终指向刚刚访问过的结点 */</span>
<span class="cm">/* 中序遍历进行中序线索化 */</span>
<span class="kt">void</span> <span class="nf">InThreading</span><span class="p">(</span><span class="n">BiThrTree</span> <span class="n">p</span><span class="p">)</span>
<span class="p">{</span> 
	<span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">InThreading</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">);</span> <span class="cm">/* 递归左子树线索化 */</span>
		<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">)</span> 			<span class="cm">/* 没有左孩子 */</span>
		<span class="p">{</span>
			<span class="n">p</span><span class="o">-&gt;</span><span class="n">LTag</span><span class="o">=</span><span class="n">Thread</span><span class="p">;</span> 	<span class="cm">/* 前驱线索 */</span>
			<span class="n">p</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="o">=</span><span class="n">pre</span><span class="p">;</span> 		<span class="cm">/* 左孩子指针指向前驱 */</span>
		<span class="p">}</span>
		<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">pre</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">)</span> 		<span class="cm">/* 前驱没有右孩子 */</span>
		<span class="p">{</span>
			<span class="n">pre</span><span class="o">-&gt;</span><span class="n">RTag</span><span class="o">=</span><span class="n">Thread</span><span class="p">;</span> 	<span class="cm">/* 后继线索 */</span>
			<span class="n">pre</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="o">=</span><span class="n">p</span><span class="p">;</span> 		<span class="cm">/* 前驱右孩子指针指向后继(当前结点p) */</span>
		<span class="p">}</span>
		<span class="n">pre</span><span class="o">=</span><span class="n">p</span><span class="p">;</span> 					<span class="cm">/* 保持pre指向p的前驱 */</span>
		<span class="n">InThreading</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">);</span> <span class="cm">/* 递归右子树线索化 */</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="树森林与二叉树的相互转化方法">树、森林与二叉树的相互转化方法</h3>
<h4 id="树转换为二叉树">树转换为二叉树</h4>
<p>转换规则：兄弟相连，长兄为父，孩子靠左。</p>
<ol>
<li>加线。在所有的兄弟结点之间加一条线。</li>
<li>去线。树中的每个结点，只保留它与第一个孩子结点的连线，删除其他孩子结点之间的连线。</li>
<li>调整。以树的根结点为轴心，将整个树调节一下（第一个孩子是结点的左孩子，兄弟转过来的孩子是结点的右孩子）。</li>
</ol>
<p><img src="/p/%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9/151758437356873.png"
	width="485"
	height="410"
	srcset="/p/%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9/151758437356873_hu6f827db1c1a4f3445cf5ba50b85a0690_121655_480x0_resize_box_3.png 480w, /p/%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9/151758437356873_hu6f827db1c1a4f3445cf5ba50b85a0690_121655_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="118"
		data-flex-basis="283px"
	
></p>
<h4 id="森林转二叉树">森林转二叉树</h4>
<ol>
<li>把每棵树转换为二叉树。</li>
<li>第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子，用线连接起来。</li>
</ol>
<p><img src="/p/%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9/151758066106515.png"
	width="558"
	height="390"
	srcset="/p/%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9/151758066106515_hu402f23546af7ccc65adb71d24ff419d1_106760_480x0_resize_box_3.png 480w, /p/%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9/151758066106515_hu402f23546af7ccc65adb71d24ff419d1_106760_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="143"
		data-flex-basis="343px"
	
></p>
<h4 id="二叉树转树">二叉树转树</h4>
<ol>
<li>加线。若某结点X的左孩子结点存在，则将这个左孩子的右孩子结点、右孩子的右孩子的右孩子结点……都作为结点X的孩子。</li>
<li>将结点X与这些右孩子结点用线连接起来</li>
<li>去线。删除原二叉树中所有结点与其右孩子结点的连线。</li>
<li>层次调整。</li>
</ol>
<p><img src="/p/%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9/151759123453168.png"
	width="494"
	height="422"
	srcset="/p/%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9/151759123453168_hu50892e38865f8b22c5abbde5fa4bfcee_112785_480x0_resize_box_3.png 480w, /p/%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9/151759123453168_hu50892e38865f8b22c5abbde5fa4bfcee_112785_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="117"
		data-flex-basis="280px"
	
></p>
<h4 id="二叉树转换为森林">二叉树转换为森林</h4>
<p><strong>前提：</strong></p>
<p>假如一棵二叉树的根节点有右孩子，则这棵二叉树能够转换为森林，否则转换为一棵树。</p>
<p><strong>转换规则：</strong></p>
<ol>
<li>从根节点开始，若右孩子存在，则把与右孩子结点的连线删除。</li>
<li>再查看分离后的二叉树，若其根节点的右孩子存在，则连续删除。直到所有这些根结点与右孩子的连线都删除为止。</li>
<li>将每棵分离后的二叉树转换为树。</li>
</ol>
<p><img src="/p/%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9/151759299858410.png"
	width="548"
	height="460"
	srcset="/p/%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9/151759299858410_hu58fc4c8a02b9fa3b097fc89d9bc780da_122992_480x0_resize_box_3.png 480w, /p/%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9/151759299858410_hu58fc4c8a02b9fa3b097fc89d9bc780da_122992_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="119"
		data-flex-basis="285px"
	
></p>
<h3 id="huffman树构造与编码">Huffman树构造与编码</h3>
<h4 id="huffman树的定义">Huffman树的定义</h4>
<p><strong>路径</strong>：在一棵树中，一个结点到另一个结点之间的通路，称为路径。</p>
<p><strong>路径长度</strong>：在一条路径中，每经过一个结点，路径长度都要加 1 。例如在一棵树中，规定根结点所在层数为1层，那么从根结点到第 i 层结点的路径长度为 i - 1 。</p>
<p><strong>结点的权</strong>：给每一个结点赋予一个新的数值，被称为这个结点的权。</p>
<p><strong>结点的带权路径长度</strong>：指的是从根结点到该结点之间的路径长度与该结点的权的乘积。</p>
<p><strong>树的带权路径长度</strong>：树中所有叶子结点的带权路径长度之和。通常记作 “WPL” 。</p>
<p>当用 n 个结点（都做叶子结点且都有各自的权值）试图构建一棵树时，如果构建的这棵树的带权路径长度最小，称这棵树为“最优二叉树”，有时也叫“赫夫曼树”或者“哈夫曼树”。</p>
<p>在构建哈弗曼树时，要使树的带权路径长度最小，只需要遵循一个原则，那就是：权重越大的结点离树根越近。</p>
<h4 id="构建huffman树">构建Huffman树</h4>
<p>对于给定的有各自权值的 n 个结点，构建哈夫曼树有一个行之有效的办法：</p>
<ol>
<li>在 n 个权值中选出两个最小的权值，对应的两个结点组成一个新的二叉树，且新二叉树的根结点的权值为左右孩子权值的和；</li>
<li>在原有的 n 个权值中删除那两个最小的权值，同时将新的权值加入到 n–2 个权值的行列中，以此类推；</li>
<li>重复 1 和 2 ，直到所以的结点构建成了一棵二叉树为止，这棵树就是哈夫曼树。</li>
</ol>
<p><img src="/p/%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9/2-1FZ509425D12.png"
	width="427"
	height="433"
	srcset="/p/%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9/2-1FZ509425D12_hu8ae47449ffc5767f2ca72fa6866fe583_28463_480x0_resize_box_3.png 480w, /p/%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9/2-1FZ509425D12_hu8ae47449ffc5767f2ca72fa6866fe583_28463_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="98"
		data-flex-basis="236px"
	
></p>
<h4 id="huffman树的存储结构">Huffman树的存储结构</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="c1">//哈夫曼树结点结构
</span><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">weight</span><span class="p">;</span><span class="c1">//结点权重
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">parent</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">;</span>
    <span class="c1">//父结点、左孩子、右孩子在数组中的位置下标
</span><span class="c1"></span><span class="p">}</span><span class="n">HTNode</span><span class="p">,</span> <span class="o">*</span><span class="n">HuffmanTree</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">char</span> <span class="o">*</span> <span class="o">*</span> <span class="n">HuffmanCode</span><span class="p">;</span>
<span class="c1">//动态分配数组存储Huffman编码表
</span></code></pre></td></tr></table>
</div>
</div><h4 id="huffman编码">Huffman编码</h4>
<p>根据发送信息的内容，通过统计文本中相同字符的个数作为每个字符的权值，建立哈夫曼树。对于树中的每一个子树，统一规定其左孩子标记为 0 ，右孩子标记为 1 。这样，用到哪个字符时，从哈夫曼树的根结点开始，依次写出经过结点的标记，最终得到的就是该结点的哈夫曼编码。</p>
<p><img src="/p/%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9/2-1FZ5095536108.png"
	width="167"
	height="201"
	srcset="/p/%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9/2-1FZ5095536108_hu0791f9ff5d6b288e34236943bcb241cb_10022_480x0_resize_box_3.png 480w, /p/%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9/2-1FZ5095536108_hu0791f9ff5d6b288e34236943bcb241cb_10022_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="83"
		data-flex-basis="199px"
	
></p>
<p>如图所示，字符 a 用到的次数最多，其次是字符 b 。字符 a 在哈夫曼编码是 <code>0</code> ，字符 b 编码为 <code>10</code> ，字符 c 的编码为 <code>110</code> ，字符 d 的编码为 <code>111</code> 。</p>
<p>使用程序求哈夫曼编码有两种方法：</p>
<ol>
<li>从叶子结点一直找到根结点，逆向记录途中经过的标记。例如，图中字符 c 的哈夫曼编码从结点 c 开始一直找到根结点，结果为：0 1 1 ，所以字符 c 的哈夫曼编码为：1 1 0（逆序输出）。</li>
<li>从根结点出发，一直到叶子结点，记录途中经过的标记。例如，求图中字符 c 的哈夫曼编码，就从根结点开始，依次为：1 1 0。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* 方法一 */</span>
<span class="c1">//HT为哈夫曼树，HC为存储结点哈夫曼编码的二维动态数组，n为结点的个数
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">HuffmanCoding</span><span class="p">(</span><span class="n">HuffmanTree</span> <span class="n">HT</span><span class="p">,</span> <span class="n">HuffmanCode</span> <span class="o">*</span><span class="n">HC</span><span class="p">,</span><span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
    <span class="o">*</span><span class="n">HC</span> <span class="o">=</span> <span class="p">(</span><span class="n">HuffmanCode</span><span class="p">)</span> <span class="n">malloc</span><span class="p">((</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">));</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">cd</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">));</span> <span class="c1">//存放结点哈夫曼编码的字符串数组
</span><span class="c1"></span>    <span class="n">cd</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span><span class="c1">//字符串结束符
</span><span class="c1"></span>   
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="c1">//从叶子结点出发，得到的哈夫曼编码是逆序的，需要在字符串数组中逆序存放
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="c1">//当前结点在数组中的位置
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="c1">//当前结点的父结点在数组中的位置
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">HT</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">parent</span><span class="p">;</span>
        <span class="c1">// 一直寻找到根结点
</span><span class="c1"></span>        <span class="k">while</span><span class="p">(</span><span class="n">j</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">){</span>
            <span class="c1">// 如果该结点是父结点的左孩子则对应路径编码为0，否则为右孩子编码为1
</span><span class="c1"></span>            <span class="k">if</span><span class="p">(</span><span class="n">HT</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">left</span> <span class="o">==</span> <span class="n">c</span><span class="p">)</span>
                <span class="n">cd</span><span class="p">[</span><span class="o">--</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;0&#39;</span><span class="p">;</span>
            <span class="k">else</span>
                <span class="n">cd</span><span class="p">[</span><span class="o">--</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;1&#39;</span><span class="p">;</span>
            <span class="c1">//以父结点为孩子结点，继续朝树根的方向遍历
</span><span class="c1"></span>            <span class="n">c</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">HT</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">parent</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">//跳出循环后，cd数组中从下标 start 开始，存放的就是该结点的哈夫曼编码
</span><span class="c1"></span>        <span class="p">(</span><span class="o">*</span><span class="n">HC</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">((</span><span class="n">n</span><span class="o">-</span><span class="n">start</span><span class="p">)</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">));</span>
        <span class="n">strcpy</span><span class="p">((</span><span class="o">*</span><span class="n">HC</span><span class="p">)[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">cd</span><span class="p">[</span><span class="n">start</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="c1">//使用malloc申请的cd动态数组需要手动释放
</span><span class="c1"></span>    <span class="n">free</span><span class="p">(</span><span class="n">cd</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* 方法二 */</span>
<span class="c1">//HT为哈夫曼树，HC为存储结点哈夫曼编码的二维动态数组，n为结点的个数
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">HuffmanCoding</span><span class="p">(</span><span class="n">HuffmanTree</span> <span class="n">HT</span><span class="p">,</span> <span class="n">HuffmanCode</span> <span class="o">*</span><span class="n">HC</span><span class="p">,</span><span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
    <span class="o">*</span><span class="n">HC</span> <span class="o">=</span> <span class="p">(</span><span class="n">HuffmanCode</span><span class="p">)</span> <span class="n">malloc</span><span class="p">((</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">));</span>
    <span class="kt">int</span> <span class="n">m</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">p</span><span class="o">=</span><span class="n">m</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">cdlen</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">cd</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">));</span>
    <span class="c1">//将各个结点的权重用于记录访问结点的次数，首先初始化为0
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">HT</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">weight</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">//一开始 p 初始化为 m，也就是从树根开始。一直到p为0
</span><span class="c1"></span>    <span class="k">while</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">//如果当前结点一次没有访问，进入这个if语句
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">HT</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">weight</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">HT</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">weight</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="c1">//重置访问次数为1
</span><span class="c1"></span>            <span class="c1">//如果有左孩子，则访问左孩子，并且存储走过的标记为0
</span><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">HT</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">left</span><span class="o">!=</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">p</span><span class="o">=</span><span class="n">HT</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">left</span><span class="p">;</span>
                <span class="n">cd</span><span class="p">[</span><span class="n">cdlen</span><span class="o">++</span><span class="p">]</span><span class="o">=</span><span class="sc">&#39;0&#39;</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="c1">//当前结点没有左孩子，也没有右孩子，说明为叶子结点，直接记录哈夫曼编码
</span><span class="c1"></span>            <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">HT</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">right</span><span class="o">==</span><span class="mi">0</span><span class="p">){</span>
                <span class="p">(</span><span class="o">*</span><span class="n">HC</span><span class="p">)[</span><span class="n">p</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">((</span><span class="n">cdlen</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">));</span>
                <span class="n">cd</span><span class="p">[</span><span class="n">cdlen</span><span class="p">]</span><span class="o">=</span><span class="sc">&#39;\0&#39;</span><span class="p">;</span>
                <span class="n">strcpy</span><span class="p">((</span><span class="o">*</span><span class="n">HC</span><span class="p">)[</span><span class="n">p</span><span class="p">],</span> <span class="n">cd</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="c1">//如果weight为1，说明访问过一次，即是从其左孩子返回的
</span><span class="c1"></span>        <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">HT</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">weight</span><span class="o">==</span><span class="mi">1</span><span class="p">){</span>
            <span class="n">HT</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">weight</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span><span class="c1">//设置访问次数为2
</span><span class="c1"></span>            <span class="c1">//如果有右孩子，遍历右孩子，记录标记值 1
</span><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">HT</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">right</span><span class="o">!=</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">p</span><span class="o">=</span><span class="n">HT</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">right</span><span class="p">;</span>
                <span class="n">cd</span><span class="p">[</span><span class="n">cdlen</span><span class="o">++</span><span class="p">]</span><span class="o">=</span><span class="sc">&#39;1&#39;</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="c1">//如果访问次数为 2，说明左右孩子都遍历完了，返回父结点
</span><span class="c1"></span>        <span class="k">else</span><span class="p">{</span>
            <span class="n">HT</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">weight</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
            <span class="n">p</span><span class="o">=</span><span class="n">HT</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">parent</span><span class="p">;</span>
            <span class="o">--</span><span class="n">cdlen</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="图">图</h2>
<h3 id="图的定义">图的定义</h3>
<p>图G由两个集合V、E构成，V是节点的有限非空集合,E是节点的二元组集合，节点二元组称为边。V(G)和E(G)分别称为图G的节点集（顶点集）与边集，也可用G=(V,E)表示图。</p>
<p><strong>线性表、树、图的差异</strong>：</p>
<ol>
<li>在线性表中数据元素叫元素，在树中将数据元素叫结点，在图中数据元素称之为顶点（Vertex）。</li>
<li>线性表中可以没有数据元素，称为空表。树中可以没有结点，叫做空树。在图结构中，不允许没有顶点。在定义中，若V是顶点的集合，则强调了顶点集合V有穷非空。</li>
<li>线性表中，相邻的数据元素之间具有线性关系，树结构中，相邻两层的结点具有层次关系，图中任意两个顶点之间都可能有关系，顶点之间的逻辑关系用边来表示，边集可以是空的。</li>
</ol>
<h3 id="图的分类">图的分类</h3>
<ol>
<li>
<p><strong>无向图</strong>
若顶点 Vi 到 Vj 之间的边没有方向，则称这条边为无向边（Edge），用无序偶对(Vi ,Vj)来表示。如果图中任意两个顶点之间的边都是无向边，则称该图为无向图（Undirected Graphs），如图所示：</p>
<p>可看出图2-1中的顶点集和边集如下：</p>
<ul>
<li>顶点集：V~1~={A,B,C,D}</li>
<li>边集：E~1~={(A,B),(B,C),(A,C),(A,D)}</li>
</ul>
</li>
</ol>
<p><img src="/p/%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9/20201018130436896.png"
	width="245"
	height="302"
	srcset="/p/%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9/20201018130436896_hu4adbcda79bc422d3595a440f4e85fb87_9039_480x0_resize_box_3.png 480w, /p/%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9/20201018130436896_hu4adbcda79bc422d3595a440f4e85fb87_9039_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="81"
		data-flex-basis="194px"
	
></p>
<ol start="2">
<li>
<p><strong>有向图</strong>
若从顶点Vi 到 Vj 的边有方向，则称这条边为有向边，也称为弧（Arc）。一般采用尖括号括起来表示，例如&lt;Vi ,Vj&gt;。前者Vi称为弧尾（Tail），后者Vj称为弧头（Head）。如果图中任意两个顶点之间的边都是有向边，则称该图为有向图（Directed graphs），如图所示：</p>
<p>其顶点集V和弧集E如下：</p>
<ul>
<li>顶点集：V2={A,B,C,D}</li>
<li>弧集：E2={&lt;B,A&gt;,&lt;A,D&gt;,&lt;A,C&gt;,&lt;B,C&gt;}</li>
</ul>
</li>
</ol>
<p><img src="/p/%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9/20201018131934601.png"
	width="245"
	height="302"
	srcset="/p/%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9/20201018131934601_huba627fa21ef0f3e7548897eda58ab287_9468_480x0_resize_box_3.png 480w, /p/%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9/20201018131934601_huba627fa21ef0f3e7548897eda58ab287_9468_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="81"
		data-flex-basis="194px"
	
></p>
<ol start="3">
<li><strong>无向完全图</strong>
在一个具有n个顶点的无向图中，倘若每个顶点与其他n-1个顶点之间都有边相连，则会有n(n-1)/2条边，这是具有n个顶点的无向图可能的最大边数。一个具有n(n-1)/2条边的n个顶点的无向图被称为无向完全图。如图所示：</li>
</ol>
<p><img src="/p/%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9/20201018133442473.png"
	width="268"
	height="216"
	srcset="/p/%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9/20201018133442473_huadca309b1ae9bb41f9bfc315fe629349_7517_480x0_resize_box_3.png 480w, /p/%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9/20201018133442473_huadca309b1ae9bb41f9bfc315fe629349_7517_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="124"
		data-flex-basis="297px"
	
></p>
<ol start="4">
<li><strong>有向完全图</strong>
在一个具有n顶点的有向图中，最多可能有n(n-1)条弧，具有n(n-1)条弧的n个顶点的有向图称为完全有向图，如图所示：</li>
</ol>
<p><img src="/p/%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9/20201018135058133.png"
	width="268"
	height="216"
	srcset="/p/%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9/20201018135058133_hu1d61b3c32ef83eae802fa8a93fdf579a_10260_480x0_resize_box_3.png 480w, /p/%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9/20201018135058133_hu1d61b3c32ef83eae802fa8a93fdf579a_10260_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="124"
		data-flex-basis="297px"
	
></p>
<ol start="5">
<li><strong>子图</strong>
图中右侧灰色部分均为前者的子图。</li>
</ol>
<p><img src="/p/%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9/20201018140626312.png"
	width="973"
	height="302"
	srcset="/p/%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9/20201018140626312_huae6bb294dfb0edb76a200a404eb6481f_30861_480x0_resize_box_3.png 480w, /p/%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9/20201018140626312_huae6bb294dfb0edb76a200a404eb6481f_30861_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="322"
		data-flex-basis="773px"
	
></p>
<ol start="6">
<li><strong>带权图</strong>
在带权图中每条边都有相应的权重，称为边权值，它可以用来表示结点之间的距离或者两结点“走动”的代价，加权图又被称为网络，如图所示：</li>
</ol>
<p><img src="/p/%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9/20201024204005233.png"
	width="245"
	height="302"
	srcset="/p/%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9/20201024204005233_hu6e6aec432e6907e2466113a0a4707184_10141_480x0_resize_box_3.png 480w, /p/%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9/20201024204005233_hu6e6aec432e6907e2466113a0a4707184_10141_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="81"
		data-flex-basis="194px"
	
></p>
<h3 id="图的基本术语">图的基本术语</h3>
<ol>
<li>
<p>邻接
若（V~1~，V~2~）是E(G)中的一条边，则称顶点V~1~和V~2~是相邻接（Adjacent）的顶点，称边（V~1~，V~2~）是依附于顶点V~1~和V~2~的边；</p>
</li>
<li>
<p>路径
顶点V~i~到顶点V~j~之间的连线称为路径（Path）；</p>
</li>
<li>
<p>简单路径
在一条路径中，如果除了第一个顶点和最后一个顶点外，其余顶点各不相同，则称这样的路径为简单路径；</p>
</li>
<li>
<p>回路（环）
若一条路径的起点和终点相同（即V~i~=V~j~），则称此路径为<strong>回路</strong>或者<strong>环</strong>；</p>
</li>
<li>
<p>简单回路（简单环）
在一个图的序列中除过第一个顶点与最后一个顶点之外，其他顶点不重复出现的回路称为简单回路或者简单环；</p>
</li>
<li>
<p>顶点的度
顶点的<strong>度</strong>是指依附于某顶点Vi的边数，通常记为TD(V~i~)；
顶点的<strong>入度</strong>（InDegree）是指以Vi为终点的弧的而数目，记为ID(V~i~)；
顶点的<strong>出度</strong>（OutDegree）是指以Vi为始点的弧的数目，记为OD(V~i~)；
于是有：TD(V~i~) = ID(V~i~)+OD(V~i~)</p>
</li>
<li>
<p>联通
若从顶点V~i~到顶点V~j~（ i ≠ j ）有路径，则V~i~和V~j~是联通的；</p>
</li>
<li>
<p>连通图
在无向图中，任意两个顶点Vi和Vj都是联通的，则称这样的无向图为连通图；</p>
</li>
<li>
<p>连通分量</p>
<p>无向图中的极大连通子图称为连通分量。</p>
</li>
<li>
<p>强连通图
在有向图中，任意一对顶点V~i~和V~j~（ i ≠ j ）均有从V~i~到V~j~和从V~j~到V~i~的有向路径，则称为强连通图。</p>
</li>
<li>
<p>强连通分量</p>
<p>有向图中的极大强连通子图称为有向图的强连通分量；</p>
</li>
<li>
<p>稀疏图</p>
<p>有很少条边或弧（如e&lt;n*log(n)）的图称为稀疏图，反之则为稠密图。</p>
</li>
<li>
<p>有向树</p>
<p>在有向图中恰有一个顶点入度为0，其余顶点入度为1，则是一颗有向树。</p>
</li>
<li>
<p>生成森林</p>
<p>一个有向图的生成森林由若干棵有向树组成，含有图中全部顶点，但只有足以构成若干棵不相交的有向树的弧。</p>
</li>
</ol>
<h3 id="图的存储结构">图的存储结构</h3>
<h4 id="数组邻接矩阵表示法">数组（邻接矩阵）表示法</h4>
<p>图的邻接矩阵（Adjacency Matrix）存储方式是用两个数组来表示图。一个一维数组存储图中顶点信息，一个二维数组（称为领接矩阵）存储图中的边或弧的信息。</p>
<ol>
<li>无向图</li>
</ol>
<p><img src="/p/%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9/1363578-20180630145407658-593980095.png"
	width="624"
	height="276"
	srcset="/p/%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9/1363578-20180630145407658-593980095_hu8f2e87bf47a148d464caf3d08239a940_80439_480x0_resize_box_3.png 480w, /p/%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9/1363578-20180630145407658-593980095_hu8f2e87bf47a148d464caf3d08239a940_80439_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="226"
		data-flex-basis="542px"
	
></p>
<ul>
<li>无向图的邻接矩阵的第i行或第i列的非零元素个数正好是第i个顶点的度。</li>
<li>无向图的邻接矩阵计算方法是每条边为对应的单元加上1，而每个自环加上2。这样让某一节点的度数可以通过邻接矩阵的对应行或者列求和得到。</li>
</ul>
<ol start="2">
<li>
<p>有向图</p>
<p><img src="/p/%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9/1363578-20180630145427267-528480203.png"
	width="709"
	height="321"
	srcset="/p/%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9/1363578-20180630145427267-528480203_hub4e7315c812e224f97e1b9c10dc1c596_95657_480x0_resize_box_3.png 480w, /p/%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9/1363578-20180630145427267-528480203_hub4e7315c812e224f97e1b9c10dc1c596_95657_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="220"
		data-flex-basis="530px"
	
></p>
<ul>
<li>有向图的邻接矩阵的第i行的非零元素个数正好是第i个顶点的出度，第i列的非零元素个数正好是第i个顶点的入度。</li>
</ul>
</li>
<li>
<p>带权值的网图</p>
</li>
</ol>
<p><img src="/p/%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9/1363578-20180630145516591-82893895.png"
	width="647"
	height="304"
	srcset="/p/%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9/1363578-20180630145516591-82893895_hub30df5ca02ade06492e666a2ec770a5a_91436_480x0_resize_box_3.png 480w, /p/%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9/1363578-20180630145516591-82893895_hub30df5ca02ade06492e666a2ec770a5a_91436_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="212"
		data-flex-basis="510px"
	
></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="cm">/* 图的邻接矩阵表示法 */</span>
<span class="k">typedef</span> <span class="kt">char</span> <span class="n">VertexType</span><span class="p">;</span> 	<span class="cm">/* 顶点类型应由用户定义  */</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="n">EdgeType</span><span class="p">;</span> 		<span class="cm">/* 边上的权值类型应由用户定义 */</span>
<span class="cp">#define MAXVEX 100 			</span><span class="cm">/* 最大顶点数，应由用户定义 */</span><span class="cp">
</span><span class="cp">#define INFINITY 65535		</span><span class="cm">/* 用65535来代表∞ */</span><span class="cp">
</span><span class="cp"></span><span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
	<span class="n">VertexType</span> <span class="n">vexs</span><span class="p">[</span><span class="n">MAXVEX</span><span class="p">];</span> 		<span class="cm">/* 顶点表 */</span>
	<span class="n">EdgeType</span> <span class="n">arc</span><span class="p">[</span><span class="n">MAXVEX</span><span class="p">][</span><span class="n">MAXVEX</span><span class="p">];</span>	<span class="c1">//邻接矩阵，可看作边表
</span><span class="c1"></span>	<span class="kt">int</span> <span class="n">numNodes</span><span class="p">,</span> <span class="n">numEdges</span><span class="p">;</span> 		<span class="c1">//图中当前的顶点数和边数 
</span><span class="c1"></span><span class="p">}</span><span class="n">MGraph</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">CreateMGraph</span><span class="p">(</span><span class="n">MGraph</span> <span class="o">&amp;</span><span class="n">G</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">w</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;请输入顶点数和边数:&#34;</span><span class="p">);</span>
    <span class="n">scanf</span><span class="p">(</span><span class="s">&#34;%d %d&#34;</span><span class="p">,</span><span class="o">&amp;</span><span class="n">G</span><span class="p">.</span><span class="n">numNodes</span><span class="p">,</span><span class="o">&amp;</span><span class="n">G</span><span class="p">.</span><span class="n">numEdges</span><span class="p">);</span>
    <span class="n">fflush</span><span class="p">(</span><span class="n">stdin</span><span class="p">);</span> 
    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">G</span><span class="p">.</span><span class="n">numNodes</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;请第%d个顶点信息:&#34;</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">scanf</span><span class="p">(</span><span class="s">&#34;%c&#34;</span><span class="p">,</span><span class="o">&amp;</span><span class="n">G</span><span class="p">.</span><span class="n">vexs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="n">fflush</span><span class="p">(</span><span class="n">stdin</span><span class="p">);</span> 
    <span class="p">}</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">G</span><span class="p">.</span><span class="n">numNodes</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">G</span><span class="p">.</span><span class="n">numNodes</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
            <span class="n">G</span><span class="p">.</span><span class="n">arc</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">INF</span><span class="p">;</span><span class="c1">//初始化二维数组的值都为INF
</span><span class="c1"></span> 
    <span class="k">for</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">k</span><span class="o">&lt;</span><span class="n">G</span><span class="p">.</span><span class="n">numEdges</span><span class="p">;</span><span class="n">k</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;请输入第%d条边的两个顶点及其权值:&#34;</span><span class="p">,</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">scanf</span><span class="p">(</span><span class="s">&#34;%d %d %d&#34;</span><span class="p">,</span><span class="o">&amp;</span><span class="n">i</span><span class="p">,</span><span class="o">&amp;</span><span class="n">j</span><span class="p">,</span><span class="o">&amp;</span><span class="n">w</span><span class="p">);</span>
        <span class="n">G</span><span class="p">.</span><span class="n">arc</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">w</span><span class="p">;</span><span class="c1">//将权值赋给该二维数组中对应的边
</span><span class="c1"></span>        <span class="n">G</span><span class="p">.</span><span class="n">arc</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">w</span><span class="p">;</span><span class="c1">//无向图，权值在二位数组中对称
</span><span class="c1"></span>        <span class="c1">//如果是有向图无需最后一段代码，即俩顶点之间可能不互通，一条边只有一个方向
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="c1">//遍历
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">TravelMGraph</span><span class="p">(</span><span class="n">MGraph</span> <span class="n">G</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">G</span><span class="p">.</span><span class="n">numNodes</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">G</span><span class="p">.</span><span class="n">numNodes</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>  
            <span class="k">if</span><span class="p">(</span><span class="n">G</span><span class="p">.</span><span class="n">arc</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">==</span><span class="n">INF</span><span class="p">)</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">&#34;∞</span><span class="se">\t</span><span class="s">&#34;</span><span class="p">);</span><span class="c1">//用∞代表俩顶点之间无联系
</span><span class="c1"></span>                <span class="k">else</span>
                    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%d</span><span class="se">\t</span><span class="s">&#34;</span><span class="p">,</span><span class="n">G</span><span class="p">.</span><span class="n">arc</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]);</span>
        <span class="p">}</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="c1">//查找
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">LocateMGraph</span><span class="p">(</span><span class="n">MGraph</span> <span class="n">G</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;请输入需要查找的顶点编号:&#34;</span><span class="p">);</span>
    <span class="n">scanf</span><span class="p">(</span><span class="s">&#34;%d&#34;</span><span class="p">,</span><span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;该顶点信息为:%c</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">G</span><span class="p">.</span><span class="n">vexs</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]);</span>
 
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;请输入需要查找边的两个顶点编号:&#34;</span><span class="p">);</span>
    <span class="n">scanf</span><span class="p">(</span><span class="s">&#34;%d %d&#34;</span><span class="p">,</span><span class="o">&amp;</span><span class="n">i</span><span class="p">,</span><span class="o">&amp;</span><span class="n">j</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;该边的权值为:%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">G</span><span class="p">.</span><span class="n">arc</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="邻接表">邻接表</h4>
<p>在图中，如果两个点相互连通，即通过其中一个顶点，可直接找到另一个顶点，则称它们互为邻接点。</p>
<p>邻接指的是图中顶点之间有边或者弧的存在。</p>
<p>邻接表存储图的实现方式是，给图中的各个顶点独自建立一个链表，用节点存储该顶点，用链表中其他节点存储各自的临接点。</p>
<p>1．图中顶点用一个一维数组存储，当然，顶点也可以用单链表来存储，不过数组可以较容易地读取顶点信息，更加方便。另外，对于顶点数组中，每个数据元素还需要存储指向第一个邻接点的指针，以便于查找该顶点的边信息。</p>
<p>2．图中每个顶点vi的所有邻接点构成一个线性表，由于邻接点的个数不定，所以用单链表存储，无向图称为顶点vi的边表，有向图则称为顶点vi作为弧尾的出边表。</p>
<p><img src="/image-20220103211104294.png"
	
	
	
	loading="lazy"
	
	
></p>
<p>从图中我们知道，顶点表的各个结点由data和firstedge两个域表示，data是数据域，存储顶点的信息，firstedge是指针域，指向边表的第一个结点，即此顶点的第一个邻接点。边表结点由adjvex和next两个域组成。adjvex是邻接点域，存储某顶点的邻接点在顶点表中的下标，next则存储指向边表中下一个结点的指针。比如v1顶点与v0、v2互为邻接点，则在v1的边表中，adjvex分别为v0的0和v2的2。</p>
<p>这样的结构，对于我们要获得图的相关信息也是很方便的。比如我们要想知道某个顶点的度，就去查找这个顶点的边表中结点的个数。若要判断顶点vi到vj是否存在边，只需要测试顶点vi的边表中adjvex是否存在结点vj的下标j就行了。若求顶点的所有邻接点，其实就是对此顶点的边表进行遍历，得到的adjvex域对应的顶点就是邻接点。</p>
<p>若是有向图，邻接表结构是类似的，比如图中第一幅图的邻接表就是第二幅图。但要注意的是有向图由于有方向，我们是<strong>以顶点为弧尾来存储边表</strong>的，这样很容易就可以得到每个顶点的出度。但也有时为了便于确定顶点的入度或以顶点为弧头的弧，我们可以建立<strong>一个有向图的逆邻接表，即对每个顶点vi都建立一个链接为vi为弧头的表</strong>。如图所示。</p>
<p><img src="/p/%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9/QQ%E6%88%AA%E5%9B%BE20220103211420.png"
	width="1564"
	height="1365"
	srcset="/p/%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9/QQ%E6%88%AA%E5%9B%BE20220103211420_hu0244bd3999dcb339085fd4a92837b882_206046_480x0_resize_box_3.png 480w, /p/%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9/QQ%E6%88%AA%E5%9B%BE20220103211420_hu0244bd3999dcb339085fd4a92837b882_206046_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="114"
		data-flex-basis="274px"
	
></p>
<p>此时我们很容易就可以算出某个顶点的入度或出度是多少，判断两顶点是否存在弧也很容易实现。</p>
<p>对于带权值的网图，可以在边表结点定义中再增加一个weight的数据域，存储权值信息即可，如图所示。</p>
<p><img src="/p/%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9/QQ%E6%88%AA%E5%9B%BE20220103212033.png"
	width="3140"
	height="1111"
	srcset="/p/%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9/QQ%E6%88%AA%E5%9B%BE20220103212033_hud171ed5a18030f05b067b21d926557cb_353659_480x0_resize_box_3.png 480w, /p/%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9/QQ%E6%88%AA%E5%9B%BE20220103212033_hud171ed5a18030f05b067b21d926557cb_353659_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="282"
		data-flex-basis="678px"
	
></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">	<span class="k">typedef</span> <span class="kt">char</span> <span class="n">VertexType</span><span class="p">;</span>  <span class="cm">/* 顶点类型应由用户定义 */</span>
    <span class="k">typedef</span> <span class="kt">int</span> <span class="n">EdgeType</span><span class="p">;</span>     <span class="cm">/* 边上的权值类型应由用户定义 */</span>

    <span class="k">typedef</span> <span class="k">struct</span> <span class="n">EdgeNode</span>   <span class="cm">/* 边表结点 */</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">adjvex</span><span class="p">;</span>        
        <span class="cm">/* 邻接点域，存储该顶点对应的下标 */</span>
        <span class="n">EdgeType</span> <span class="n">weight</span><span class="p">;</span>   
        <span class="cm">/* 用于存储权值，对于非网图可以不需要 */</span>
        <span class="k">struct</span> <span class="n">EdgeNode</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span> 
        <span class="cm">/* 链域，指向下一个邻接点 */</span>
    <span class="p">}</span><span class="n">EdgeNode</span><span class="p">;</span>

    <span class="k">typedef</span> <span class="k">struct</span> <span class="n">VertexNode</span>      <span class="cm">/* 顶点表结点 */</span>
    <span class="p">{</span>
        <span class="n">VertexType</span> <span class="n">data</span><span class="p">;</span>           
        <span class="cm">/* 顶点域，存储顶点信息*/</span>
        <span class="n">EdgeNode</span> <span class="o">*</span><span class="n">firstedge</span><span class="p">;</span>       
        <span class="cm">/* 边表头指针 */</span>
    <span class="p">}</span><span class="n">VertexNode</span><span class="p">,</span> <span class="n">AdjList</span><span class="p">[</span><span class="n">MAXVEX</span><span class="p">];</span>

    <span class="k">typedef</span> <span class="k">struct</span>
    <span class="p">{</span>
        <span class="n">AdjList</span> <span class="n">adjList</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">numVertexes</span><span class="p">,</span><span class="n">numEdges</span><span class="p">;</span> 
        <span class="cm">/* 图中当前顶点数和边数 */</span>
    <span class="p">}</span><span class="n">GraphAdjList</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="图的遍历">图的遍历</h3>
<h4 id="深度优先搜索">深度优先搜索</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#define MAXVEX 9
</span><span class="cp"></span><span class="n">Boolean</span> <span class="n">visited</span><span class="p">[</span><span class="n">MAXVEX</span><span class="p">];</span> 				
<span class="cm">/* 访问标志的数组 */</span>
<span class="cm">/* 邻接矩阵的深度优先递归算法 */</span>
<span class="kt">void</span> <span class="nf">DFS</span><span class="p">(</span><span class="n">MGraph</span> <span class="n">G</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
 	<span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
 	<span class="n">printf</span><span class="p">(</span><span class="s">&#34;%c &#34;</span><span class="p">,</span> <span class="n">G</span><span class="p">.</span><span class="n">vexs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>			
    <span class="cm">/* 打印顶点，也可以其它操作 */</span>
	<span class="k">for</span><span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">G</span><span class="p">.</span><span class="n">numVertexes</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span><span class="p">(</span><span class="n">G</span><span class="p">.</span><span class="n">arc</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
 			<span class="n">DFS</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>					
    <span class="cm">/* 对为访问的邻接顶点递归调用 */</span>
<span class="p">}</span>

<span class="cm">/* 邻接矩阵的深度遍历操作 */</span>
<span class="kt">void</span> <span class="nf">DFSTraverse</span><span class="p">(</span><span class="n">MGraph</span> <span class="n">G</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
 	<span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">G</span><span class="p">.</span><span class="n">numVertexes</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
 		<span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span> 			
    <span class="cm">/* 初始所有顶点状态都是未访问过状态 */</span>
	<span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">G</span><span class="p">.</span><span class="n">numVertexes</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
 		<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> 				
            <span class="cm">/* 对未访问过的顶点调用DFS，若连通图仅执行一次 */</span> 
			<span class="n">DFS</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* 邻接表的深度优先递归算法 */</span>
<span class="kt">void</span> <span class="nf">DFS</span><span class="p">(</span><span class="n">GraphAdjList</span> <span class="n">GL</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">EdgeNode</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
 	<span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
 	<span class="n">printf</span><span class="p">(</span><span class="s">&#34;%c &#34;</span><span class="p">,</span><span class="n">GL</span><span class="o">-&gt;</span><span class="n">adjList</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">data</span><span class="p">);</span>	
    <span class="cm">/* 打印顶点,也可以其它操作 */</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">GL</span><span class="o">-&gt;</span><span class="n">adjList</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">firstedge</span><span class="p">;</span>
	<span class="k">while</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
	<span class="p">{</span>
 		<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">adjvex</span><span class="p">])</span>
 			<span class="n">DFS</span><span class="p">(</span><span class="n">GL</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">adjvex</span><span class="p">);</span>			
        <span class="cm">/* 对为访问的邻接顶点递归调用 */</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
 	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* 邻接表的深度遍历操作 */</span>
<span class="kt">void</span> <span class="nf">DFSTraverse</span><span class="p">(</span><span class="n">GraphAdjList</span> <span class="n">GL</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
 	<span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">GL</span><span class="o">-&gt;</span><span class="n">numVertexes</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
 		<span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span> 			
    <span class="cm">/* 初始所有顶点状态都是未访问过状态 */</span>
	<span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">GL</span><span class="o">-&gt;</span><span class="n">numVertexes</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
 		<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> 				
            <span class="cm">/* 对未访问过的顶点调用DFS,若是连通图,只会执行一次 */</span> 
			<span class="n">DFS</span><span class="p">(</span><span class="n">GL</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="广度优先搜索">广度优先搜索</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* 邻接矩阵的广度遍历算法 */</span>
<span class="kt">void</span> <span class="nf">BFSTraverse</span><span class="p">(</span><span class="n">MGraph</span> <span class="n">G</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
	<span class="n">Queue</span> <span class="n">Q</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">G</span><span class="p">.</span><span class="n">numVertexes</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
       	<span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="n">InitQueue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Q</span><span class="p">);</span>									
    <span class="cm">/* 初始化一辅助用的队列 */</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">G</span><span class="p">.</span><span class="n">numVertexes</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>  			
        <span class="cm">/* 对每一个顶点做循环 */</span>
    <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>							
            <span class="cm">/* 若是未访问过就处理 */</span>
		<span class="p">{</span>
			<span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">TRUE</span><span class="p">;</span>						
            <span class="cm">/* 设置当前顶点访问过 */</span>
			<span class="n">printf</span><span class="p">(</span><span class="s">&#34;%c &#34;</span><span class="p">,</span> <span class="n">G</span><span class="p">.</span><span class="n">vexs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>				
            <span class="cm">/* 打印顶点，也可以其它操作 */</span>
			<span class="n">EnQueue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Q</span><span class="p">,</span><span class="n">i</span><span class="p">);</span>							
            <span class="cm">/* 将此顶点入队列 */</span>
			<span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">QueueEmpty</span><span class="p">(</span><span class="n">Q</span><span class="p">))</span>					
                <span class="cm">/* 若当前队列不为空 */</span>
			<span class="p">{</span>
				<span class="n">DeQueue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Q</span><span class="p">,</span><span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>						
                <span class="cm">/* 将队首元素出队列，赋值给i */</span>
				<span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">G</span><span class="p">.</span><span class="n">numVertexes</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span> 
				<span class="p">{</span>					
                    <span class="cm">/* 判断其它顶点若与当前顶点存在 */</span>							<span class="cm">/* 边且未访问过 */</span>
					<span class="k">if</span><span class="p">(</span><span class="n">G</span><span class="p">.</span><span class="n">arc</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> 
					<span class="p">{</span> 					
 						<span class="n">visited</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">TRUE</span><span class="p">;</span>			
                        <span class="cm">/* 将找到的此顶点标记为已访问 */</span>
						<span class="n">printf</span><span class="p">(</span><span class="s">&#34;%c &#34;</span><span class="p">,</span> <span class="n">G</span><span class="p">.</span><span class="n">vexs</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>	
                        <span class="cm">/* 打印顶点 */</span>
						<span class="n">EnQueue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Q</span><span class="p">,</span><span class="n">j</span><span class="p">);</span>				
                        <span class="cm">/* 将找到的此顶点入队列  */</span>
					<span class="p">}</span> 
				<span class="p">}</span> 
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* 邻接表的广度遍历算法 */</span>
<span class="kt">void</span> <span class="nf">BFSTraverse</span><span class="p">(</span><span class="n">GraphAdjList</span> <span class="n">GL</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">EdgeNode</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="n">Queue</span> <span class="n">Q</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">GL</span><span class="o">-&gt;</span><span class="n">numVertexes</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
       	<span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="n">InitQueue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Q</span><span class="p">);</span>
   	<span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">GL</span><span class="o">-&gt;</span><span class="n">numVertexes</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
   	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
		<span class="p">{</span>
			<span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">TRUE</span><span class="p">;</span>
			<span class="n">printf</span><span class="p">(</span><span class="s">&#34;%c &#34;</span><span class="p">,</span><span class="n">GL</span><span class="o">-&gt;</span><span class="n">adjList</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">data</span><span class="p">);</span>	
            <span class="cm">/* 打印顶点,也可以其它操作 */</span>
			<span class="n">EnQueue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Q</span><span class="p">,</span><span class="n">i</span><span class="p">);</span>
			<span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">QueueEmpty</span><span class="p">(</span><span class="n">Q</span><span class="p">))</span>
			<span class="p">{</span>
				<span class="n">DeQueue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Q</span><span class="p">,</span><span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>
				<span class="n">p</span> <span class="o">=</span> <span class="n">GL</span><span class="o">-&gt;</span><span class="n">adjList</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">firstedge</span><span class="p">;</span>	
                <span class="cm">/* 找到当前顶点的边表链表头指针 */</span>
				<span class="k">while</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
				<span class="p">{</span>
					<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">adjvex</span><span class="p">])</span>		
                        <span class="cm">/* 若此顶点未被访问 */</span>
 					<span class="p">{</span>
 						<span class="n">visited</span><span class="p">[</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">adjvex</span><span class="p">]</span><span class="o">=</span><span class="n">TRUE</span><span class="p">;</span>
						<span class="n">printf</span><span class="p">(</span><span class="s">&#34;%c &#34;</span><span class="p">,</span><span class="n">GL</span><span class="o">-&gt;</span><span class="n">adjList</span><span class="p">[</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">adjvex</span><span class="p">].</span><span class="n">data</span><span class="p">);</span>
						<span class="n">EnQueue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Q</span><span class="p">,</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">adjvex</span><span class="p">);</span>	
                        <span class="cm">/* 将此顶点入队列 */</span>
					<span class="p">}</span>
					<span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>				
                    <span class="cm">/* 指针指向下一个邻接点 */</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="图的连通性">图的连通性</h3>
<h4 id="最小生成树">最小生成树</h4>
<ol>
<li>
<p><a class="link" href="https://zh.wikipedia.org/wiki/%E6%99%AE%E6%9E%97%E5%A7%86%E7%AE%97%E6%B3%95"  target="_blank" rel="noopener"
    >Prim算法</a>：</p>
<p>Prim算法原理：</p>
<blockquote>
<p>1）以某一个<strong>点</strong>开始，寻找当前该点可以访问的所有的边；
2）在已经寻找的边中发现最小边，这个边必须有一个点还没有访问过，将还没有访问的点加入我们的集合，记录添加的边；
3）寻找当前集合可以访问的所有边，重复2的过程，直到没有新的点可以加入；
4）此时由所有边构成的树即为最小生成树。</p>
</blockquote>
</li>
<li>
<p><a class="link" href="https://zh.wikipedia.org/wiki/%E5%85%8B%E9%B2%81%E6%96%AF%E5%85%8B%E5%B0%94%E6%BC%94%E7%AE%97%E6%B3%95"  target="_blank" rel="noopener"
    >Kruskal算法</a>：</p>
<p>Kruskal算法原理：</p>
<blockquote>
<p>现在我们假设一个图有m个节点，n条边。</p>
<p>首先，我们需要把m个节点看成m个独立的生成树，并且把n条边按照从小到大的数据进行排列。</p>
<p>在n条边中，我们依次取出其中的每一条边，如果发现边的两个节点分别位于两棵树上，那么把两棵树合并成为一颗树；</p>
<p>如果树的两个节点位于同一棵树上，那么忽略这条边，继续运行。</p>
<p>等到所有的边都遍历结束之后，如果所有的生成树可以合并成一条生成树，那么它就是我们需要寻找的最小生成树，反之则没有最小生成树。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">伪代码：
KRUSKAL-FUNCTION(G, w)
1    F := 空集合
2    for each 图 G 中的顶点 v
3        do 将 v 加入森林 F
4    所有的边(u, v) ∈ E依权重 w 递增排序
5    for each 边(u, v) ∈ E
6        do if u 和 v 不在同一棵子树
7            then F := F ∪ {(u, v)}
8                将 u 和 v 所在的子树合并
</code></pre></td></tr></table>
</div>
</div></blockquote>
</li>
<li>
<p><a class="link" href="https://houbb.github.io/2020/01/23/data-struct-learn-03-graph-dijkstra"  target="_blank" rel="noopener"
    >迪杰斯特拉算法（Dijkstra）</a></p>
</li>
<li>
<p>Floyd算法</p>
</li>
</ol>
<h4 id="拓补排序算法">拓补排序算法</h4>
<h2 id="排序">排序</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* 对顺序表L作冒泡排序 */</span>
<span class="kt">void</span> <span class="nf">BubbleSort</span><span class="p">(</span><span class="n">SqList</span> <span class="o">*</span><span class="n">L</span><span class="p">)</span>
<span class="p">{</span> 
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">length</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="n">j</span><span class="o">&gt;=</span><span class="n">i</span><span class="p">;</span><span class="n">j</span><span class="o">--</span><span class="p">)</span> 
            <span class="cm">/* 注意j是从后往前循环 */</span>
		<span class="p">{</span>
			<span class="k">if</span><span class="p">(</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">&gt;</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> 	
                <span class="cm">/* 若前者大于后者（注意这里与上一算法的差异）*/</span>
			<span class="p">{</span>
				 <span class="n">swap</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>		
                <span class="cm">/* 交换L-&gt;r[j]与L-&gt;r[j+1]的值 */</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* 对顺序表L作简单选择排序 */</span>
<span class="kt">void</span> <span class="nf">SelectSort</span><span class="p">(</span><span class="n">SqList</span> <span class="o">*</span><span class="n">L</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">min</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span> 
		<span class="n">min</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>						
        <span class="cm">/* 将当前下标定义为最小值下标 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span>	
            <span class="cm">/* 循环之后的数据 */</span>
        <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">min</span><span class="p">]</span><span class="o">&gt;</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>		
                <span class="cm">/* 如果有小于当前最小值的关键字 */</span>
                <span class="n">min</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>				
            <span class="cm">/* 将此关键字的下标赋值给min */</span>
        <span class="p">}</span>
		<span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">!=</span><span class="n">min</span><span class="p">)</span>						
            <span class="cm">/* 若min不等于i，说明找到最小值，交换 */</span>
			<span class="n">swap</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">min</span><span class="p">);</span>				
        <span class="cm">/* 交换L-&gt;r[i]与L-&gt;r[min]的值 */</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div>
</section>


    <footer class="article-footer">
    
    <section class="article-tags">
        
            <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
        
    </section>


    </footer>


    
</article>

    

    <aside class="related-contents--wrapper">
    
    
</aside>

     
    
        
    <script src='//cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js'></script>
<div id="waline" class="waline-container"></div>
<style>
    .waline-container {
        background-color: var(--card-background);
        border-radius: var(--card-border-radius);
        box-shadow: var(--shadow-l1);
        padding: var(--card-padding);
    }
    .waline-container .vcount {
        color: var(--card-text-color-main);
    }
</style><script>
    
    new Waline({"dark":"html[data-scheme=\"dark\"]","el":"#waline","emoji":["https://cdn.jsdelivr.net/gh/walinejs/emojis@1.0.0/qq"],"lang":"zh-CN","locale":{"admin":"Admin"},"requiredMeta":["name","mail"],"serverURL":"https://yjlp76.deta.dev/","visitor":true});
</script>

    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2021 - 
        
        2022 只是一个仓库
    </section>
    
    <section class="powerby">
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        Theme <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.8.0">Stack</a></b> designed by <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a>
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="/dist/default-skin.css"integrity="sha256-c0uckgykQ9v5k&#43;IqViZOZKc47Jn7KQil4/MP3ySA3F8="crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="/dist/photoswipe.css"integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE="crossorigin="anonymous"
            >

            </main>
    
        <aside class="sidebar right-sidebar sticky">
            <section class="widget archives">
                <div class="widget-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



                </div>
                <h2 class="widget-title section-title">目录</h2>
                
                <div class="widget--toc">
                    <nav id="TableOfContents">
  <ol>
    <li><a href="#数据结构入门">数据结构入门</a>
      <ol>
        <li><a href="#数据结构基础知识">数据结构基础知识</a></li>
        <li><a href="#算法效率的度量">算法效率的度量</a></li>
      </ol>
    </li>
    <li><a href="#线性表">线性表</a>
      <ol>
        <li><a href="#顺序表">顺序表</a>
          <ol>
            <li><a href="#顺序表的静态分配">顺序表的静态分配</a></li>
            <li><a href="#顺序表的动态分配">顺序表的动态分配</a></li>
            <li><a href="#顺序表的基本操作">顺序表的基本操作</a></li>
            <li><a href="#线性表顺序存储结构的优缺点">线性表顺序存储结构的优缺点</a></li>
          </ol>
        </li>
        <li><a href="#线性表的链式存储结构">线性表的链式存储结构</a>
          <ol>
            <li><a href="#头指针与头结点的异同">头指针与头结点的异同</a></li>
            <li><a href="#线性表的单链表存储结构">线性表的单链表存储结构</a></li>
            <li><a href="#单链表的读取">单链表的读取</a></li>
            <li><a href="#单链表的插入与删除">单链表的插入与删除</a></li>
            <li><a href="#单链表结构与顺序存储结构优缺点">单链表结构与顺序存储结构优缺点</a></li>
            <li><a href="#静态链表">静态链表</a></li>
            <li><a href="#循环链表见大话数据结构p80">循环链表（见大话数据结构P~80~）</a></li>
            <li><a href="#双向链表">双向链表</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#栈和队列">栈和队列</a>
      <ol>
        <li><a href="#栈">栈</a>
          <ol>
            <li><a href="#栈的定义">栈的定义</a></li>
            <li><a href="#栈的顺序存储结构">栈的顺序存储结构</a></li>
            <li><a href="#栈的链式存储结构略">栈的链式存储结构（略）</a></li>
          </ol>
        </li>
        <li><a href="#队列">队列</a>
          <ol>
            <li><a href="#队列的定义">队列的定义</a></li>
            <li><a href="#链队列">链队列</a></li>
            <li><a href="#循环队列">循环队列</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#串">串</a>
      <ol>
        <li><a href="#串的定义略">串的定义（略）</a></li>
      </ol>
    </li>
    <li><a href="#数组和广义表">数组和广义表</a></li>
    <li><a href="#树和二叉树">树和二叉树</a>
      <ol>
        <li><a href="#树的定义">树的定义</a></li>
        <li><a href="#树的种类">树的种类</a></li>
        <li><a href="#树的存储结构">树的存储结构</a>
          <ol>
            <li><a href="#双亲表示法">双亲表示法</a></li>
            <li><a href="#孩子表示法">孩子表示法</a></li>
            <li><a href="#孩子兄弟表示法">孩子兄弟表示法</a></li>
          </ol>
        </li>
        <li><a href="#二叉树">二叉树</a>
          <ol>
            <li><a href="#二叉树的定义与特点">二叉树的定义与特点</a></li>
            <li><a href="#二叉树的性质">二叉树的性质</a></li>
            <li><a href="#二叉树的顺式存储结构">二叉树的顺式存储结构</a></li>
            <li><a href="#二叉树的链式存储结构">二叉树的链式存储结构</a></li>
            <li><a href="#二叉树的遍历">二叉树的遍历</a></li>
            <li><a href="#线索二叉树">线索二叉树</a></li>
          </ol>
        </li>
        <li><a href="#树森林与二叉树的相互转化方法">树、森林与二叉树的相互转化方法</a>
          <ol>
            <li><a href="#树转换为二叉树">树转换为二叉树</a></li>
            <li><a href="#森林转二叉树">森林转二叉树</a></li>
            <li><a href="#二叉树转树">二叉树转树</a></li>
            <li><a href="#二叉树转换为森林">二叉树转换为森林</a></li>
          </ol>
        </li>
        <li><a href="#huffman树构造与编码">Huffman树构造与编码</a>
          <ol>
            <li><a href="#huffman树的定义">Huffman树的定义</a></li>
            <li><a href="#构建huffman树">构建Huffman树</a></li>
            <li><a href="#huffman树的存储结构">Huffman树的存储结构</a></li>
            <li><a href="#huffman编码">Huffman编码</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#图">图</a>
      <ol>
        <li><a href="#图的定义">图的定义</a></li>
        <li><a href="#图的分类">图的分类</a></li>
        <li><a href="#图的基本术语">图的基本术语</a></li>
        <li><a href="#图的存储结构">图的存储结构</a>
          <ol>
            <li><a href="#数组邻接矩阵表示法">数组（邻接矩阵）表示法</a></li>
            <li><a href="#邻接表">邻接表</a></li>
          </ol>
        </li>
        <li><a href="#图的遍历">图的遍历</a>
          <ol>
            <li><a href="#深度优先搜索">深度优先搜索</a></li>
            <li><a href="#广度优先搜索">广度优先搜索</a></li>
          </ol>
        </li>
        <li><a href="#图的连通性">图的连通性</a>
          <ol>
            <li><a href="#最小生成树">最小生成树</a></li>
            <li><a href="#拓补排序算法">拓补排序算法</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#排序">排序</a></li>
  </ol>
</nav>
                </div>
            </section>
        </aside>
    

        </div>
        <script 
                src="/dist/vibrant.min.js"integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
